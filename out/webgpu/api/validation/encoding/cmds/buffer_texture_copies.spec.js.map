{"version":3,"sources":["../../../../../../src/webgpu/api/validation/encoding/cmds/buffer_texture_copies.spec.ts"],"names":["description","poptions","params","makeTestGroup","assert","kDepthStencilFormats","depthStencilBufferTextureCopySupported","depthStencilFormatAspectSize","align","kBufferCopyAlignment","kBytesPerRowAlignment","ValidationTest","ImageCopyTest","testCopyBufferToTexture","source","destination","copySize","isSuccess","encoder","device","createCommandEncoder","copyBufferToTexture","expectValidationError","queue","submit","finish","testCopyTextureToBuffer","copyTextureToBuffer","g","test","desc","cases","combine","subcases","fn","t","format","aspect","selectDeviceForTextureFormatOrSkipTestCase","textureSize","width","height","depthOrArrayLayers","texture","createTexture","size","usage","GPUTextureUsage","COPY_SRC","COPY_DST","buffer","createBuffer","GPUBufferUsage","success","filter","param","copyType","texelAspectSize","bytesPerRow","rowsPerImage","minimumBufferSize","bigEnoughBuffer","smallerBuffer","offset"],"mappings":"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","sourcesContent":["export const description = `\ncopyTextureToBuffer and copyBufferToTexture validation tests not covered by\nthe general image_copy tests, or by destroyed,*.\n\nTODO:\n- Move all the tests here to image_copy/ and test writeTexture() with depth/stencil formats.\n`;\n\nimport { poptions, params } from '../../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { assert } from '../../../../../common/framework/util/util.js';\nimport {\n  kDepthStencilFormats,\n  depthStencilBufferTextureCopySupported,\n  depthStencilFormatAspectSize,\n} from '../../../../capability_info.js';\nimport { align } from '../../../../util/math.js';\nimport { kBufferCopyAlignment, kBytesPerRowAlignment } from '../../../../util/texture/layout.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nclass ImageCopyTest extends ValidationTest {\n  testCopyBufferToTexture(\n    source: GPUImageCopyBuffer,\n    destination: GPUImageCopyTexture,\n    copySize: GPUExtent3DStrict,\n    isSuccess: boolean\n  ): void {\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyBufferToTexture(source, destination, copySize);\n    this.expectValidationError(() => {\n      this.device.queue.submit([encoder.finish()]);\n    }, !isSuccess);\n  }\n\n  testCopyTextureToBuffer(\n    source: GPUImageCopyTexture,\n    destination: GPUImageCopyBuffer,\n    copySize: GPUExtent3DStrict,\n    isSuccess: boolean\n  ): void {\n    const encoder = this.device.createCommandEncoder();\n    encoder.copyTextureToBuffer(source, destination, copySize);\n    this.expectValidationError(() => {\n      this.device.queue.submit([encoder.finish()]);\n    }, !isSuccess);\n  }\n}\n\nexport const g = makeTestGroup(ImageCopyTest);\n\ng.test('depth_stencil_format,copy_usage_and_aspect')\n  .desc(\n    `\n  Validate the combination of usage and aspect of each depth stencil format in copyBufferToTexture\n  and copyTextureToBuffer. See https://gpuweb.github.io/gpuweb/#depth-formats for more details.\n`\n  )\n  .cases(params().combine(poptions('format', kDepthStencilFormats)))\n  .subcases(() =>\n    params().combine(poptions('aspect', ['all', 'depth-only', 'stencil-only'] as const))\n  )\n  .fn(async t => {\n    const { format, aspect } = t.params;\n    await t.selectDeviceForTextureFormatOrSkipTestCase(format);\n\n    const textureSize = { width: 1, height: 1, depthOrArrayLayers: 1 };\n    const texture = t.device.createTexture({\n      size: textureSize,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const buffer = t.device.createBuffer({\n      size: 32,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    {\n      const success = depthStencilBufferTextureCopySupported('CopyB2T', format, aspect);\n      t.testCopyBufferToTexture({ buffer }, { texture, aspect }, textureSize, success);\n    }\n\n    {\n      const success = depthStencilBufferTextureCopySupported('CopyT2B', format, aspect);\n      t.testCopyTextureToBuffer({ texture, aspect }, { buffer }, textureSize, success);\n    }\n  });\n\ng.test('depth_stencil_format,copy_buffer_size')\n  .desc(\n    `\n  Validate the minimum buffer size for each depth stencil format in copyBufferToTexture\n  and copyTextureToBuffer.\n\n  Given a depth stencil format, a copy aspect ('depth-only' or 'stencil-only'), the copy method\n  (buffer-to-texture or texture-to-buffer) and the copy size, validate\n  - if the copy can be successfully executed with the minimum required buffer size.\n  - if the copy fails with a validation error when the buffer size is less than the minimum\n  required buffer size.\n`\n  )\n  .cases(\n    params()\n      .combine(poptions('format', kDepthStencilFormats))\n      .combine(poptions('aspect', ['depth-only', 'stencil-only'] as const))\n      .combine(poptions('copyType', ['CopyB2T', 'CopyT2B'] as const))\n      .filter(param =>\n        depthStencilBufferTextureCopySupported(param.copyType, param.format, param.aspect)\n      )\n  )\n  .subcases(() =>\n    params().combine(\n      poptions('copySize', [\n        { width: 8, height: 1, depthOrArrayLayers: 1 },\n        { width: 4, height: 4, depthOrArrayLayers: 1 },\n        { width: 4, height: 4, depthOrArrayLayers: 3 },\n      ])\n    )\n  )\n  .fn(async t => {\n    const { format, aspect, copyType, copySize } = t.params;\n    await t.selectDeviceForTextureFormatOrSkipTestCase(format);\n\n    const texture = t.device.createTexture({\n      size: copySize,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const texelAspectSize = depthStencilFormatAspectSize(format, aspect);\n    assert(texelAspectSize > 0);\n\n    const bytesPerRow = align(texelAspectSize * copySize.width, kBytesPerRowAlignment);\n    const rowsPerImage = copySize.height;\n    const minimumBufferSize =\n      bytesPerRow * (rowsPerImage * copySize.depthOrArrayLayers - 1) +\n      align(texelAspectSize * copySize.width, kBufferCopyAlignment);\n    assert(minimumBufferSize > kBufferCopyAlignment);\n\n    const bigEnoughBuffer = t.device.createBuffer({\n      size: minimumBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n    const smallerBuffer = t.device.createBuffer({\n      size: minimumBufferSize - kBufferCopyAlignment,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    if (copyType === 'CopyB2T') {\n      t.testCopyBufferToTexture(\n        { buffer: bigEnoughBuffer, bytesPerRow, rowsPerImage },\n        { texture, aspect },\n        copySize,\n        true\n      );\n      t.testCopyBufferToTexture(\n        { buffer: smallerBuffer, bytesPerRow, rowsPerImage },\n        { texture, aspect },\n        copySize,\n        false\n      );\n    } else {\n      assert(copyType === 'CopyT2B');\n      t.testCopyTextureToBuffer(\n        { texture, aspect },\n        { buffer: bigEnoughBuffer, bytesPerRow, rowsPerImage },\n        copySize,\n        true\n      );\n      t.testCopyTextureToBuffer(\n        { texture, aspect },\n        { buffer: smallerBuffer, bytesPerRow, rowsPerImage },\n        copySize,\n        false\n      );\n    }\n  });\n\ng.test('depth_stencil_format,copy_buffer_offset')\n  .desc(\n    `\n    Validate for every depth stencil formats the buffer offset must be a multiple of 4 in\n    copyBufferToTexture() and copyTextureToBuffer().\n    `\n  )\n  .cases(\n    params()\n      .combine(poptions('format', kDepthStencilFormats))\n      .combine(poptions('aspect', ['depth-only', 'stencil-only'] as const))\n      .combine(poptions('copyType', ['CopyB2T', 'CopyT2B'] as const))\n      .filter(param =>\n        depthStencilBufferTextureCopySupported(param.copyType, param.format, param.aspect)\n      )\n  )\n  .subcases(() => poptions('offset', [1, 2, 4, 6, 8]))\n  .fn(async t => {\n    const { format, aspect, copyType, offset } = t.params;\n    await t.selectDeviceForTextureFormatOrSkipTestCase(format);\n\n    const textureSize = { width: 4, height: 4, depthOrArrayLayers: 1 };\n\n    const texture = t.device.createTexture({\n      size: textureSize,\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const texelAspectSize = depthStencilFormatAspectSize(format, aspect);\n    assert(texelAspectSize > 0);\n\n    const bytesPerRow = align(texelAspectSize * textureSize.width, kBytesPerRowAlignment);\n    const rowsPerImage = textureSize.height;\n    const minimumBufferSize =\n      bytesPerRow * (rowsPerImage * textureSize.depthOrArrayLayers - 1) +\n      align(texelAspectSize * textureSize.width, kBufferCopyAlignment);\n    assert(minimumBufferSize > kBufferCopyAlignment);\n\n    const buffer = t.device.createBuffer({\n      size: align(minimumBufferSize + offset, kBufferCopyAlignment),\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const isSuccess = offset % 4 === 0;\n\n    if (copyType === 'CopyB2T') {\n      t.testCopyBufferToTexture(\n        { buffer, offset, bytesPerRow, rowsPerImage },\n        { texture, aspect },\n        textureSize,\n        isSuccess\n      );\n    } else {\n      assert(copyType === 'CopyT2B');\n      t.testCopyTextureToBuffer(\n        { texture, aspect },\n        { buffer, offset, bytesPerRow, rowsPerImage },\n        textureSize,\n        isSuccess\n      );\n    }\n  });\n"],"file":"buffer_texture_copies.spec.js"}