{"version":3,"sources":["../../../../src/webgpu/api/validation/createRenderPipeline.spec.ts"],"names":["description","poptions","makeTestGroup","kAllTextureFormats","kAllTextureFormatInfo","ValidationTest","F","getDescriptor","options","defaultTargets","format","topology","targets","sampleCount","depthStencil","length","fragColorType","suffix","endsWith","vertex","module","device","createShaderModule","code","entryPoint","fragment","layout","getPipelineLayout","primitive","multisample","count","createPipelineLayout","bindGroupLayouts","createTexture","params","size","width","height","depthOrArrayLayers","usage","GPUTextureUsage","RENDER_ATTACHMENT","g","test","fn","t","descriptor","createRenderPipeline","goodDescriptor","badDescriptor","expectValidationError","info","selectDeviceOrSkipTestCase","extension","renderable","color","_success","attachmentSamples","pipelineSamples","colorTexture","depthStencilTexture","renderPassDescriptorWithoutDepthStencil","colorAttachments","attachment","createView","loadValue","r","b","a","renderPassDescriptorWithDepthStencilOnly","depthStencilAttachment","depthLoadValue","depthStoreOp","stencilLoadValue","stencilStoreOp","pipelineWithoutDepthStencil","pipelineWithDepthStencilOnly","renderPassDescriptor","pipeline","commandEncoder","createCommandEncoder","renderPass","beginRenderPass","setPipeline","endPass","finish"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAvBO,CAyBP,SAASC,QAAT,QAAyB,6CAAzB;AACA,SAASC,aAAT,QAA8B,yCAA9B;AACA,SAASC,kBAAT,EAA6BC,qBAA7B,QAA0D,0BAA1D;;AAEA,SAASC,cAAT,QAA+B,sBAA/B;;AAEA,MAAMC,CAAN,SAAgBD,cAAhB,CAA+B;AAC7BE,EAAAA,aAAa;AACXC,EAAAA,OAKC;;;;;AAAG,IANO;AAOkB;AAC7B,UAAMC,cAAqC,GAAG,CAAC,EAAEC,MAAM,EAAE,YAAV,EAAD,CAA9C;AACA,UAAM;AACJC,MAAAA,QAAQ,GAAG,eADP;AAEJC,MAAAA,OAAO,GAAGH,cAFN;AAGJI,MAAAA,WAAW,GAAG,CAHV;AAIJC,MAAAA,YAJI;AAKFN,IAAAA,OALJ;;AAOA,UAAME,MAAM,GAAGE,OAAO,CAACG,MAAR,GAAiBH,OAAO,CAAC,CAAD,CAAP,CAAWF,MAA5B,GAAqC,YAApD;;AAEA,QAAIM,aAAJ;AACA,QAAIC,MAAJ;AACA,QAAIP,MAAM,CAACQ,QAAP,CAAgB,MAAhB,CAAJ,EAA6B;AAC3BF,MAAAA,aAAa,GAAG,KAAhB;AACAC,MAAAA,MAAM,GAAG,EAAT;AACD,KAHD,MAGO,IAAIP,MAAM,CAACQ,QAAP,CAAgB,MAAhB,CAAJ,EAA6B;AAClCF,MAAAA,aAAa,GAAG,KAAhB;AACAC,MAAAA,MAAM,GAAG,GAAT;AACD,KAHM,MAGA;AACLD,MAAAA,aAAa,GAAG,KAAhB;AACAC,MAAAA,MAAM,GAAG,IAAT;AACD;;AAED,WAAO;AACLE,MAAAA,MAAM,EAAE;AACNC,QAAAA,MAAM,EAAE,KAAKC,MAAL,CAAYC,kBAAZ,CAA+B;AACrCC,UAAAA,IAAI,EAAG;AACjB;AACA;AACA;AACA;AACA,cAN+C,EAA/B,CADF;;AASNC,QAAAA,UAAU,EAAE,MATN,EADH;;AAYLC,MAAAA,QAAQ,EAAE;AACRL,QAAAA,MAAM,EAAE,KAAKC,MAAL,CAAYC,kBAAZ,CAA+B;AACrCC,UAAAA,IAAI,EAAG;AACjB,wDAAwDP,aAAc;AACtE;AACA,iCAAiCA,aAAc,MAAKC,MAAO,MAAKA,MAAO,MAAKA,MAAO,MAAKA,MAAO;AAC/F,cAL+C,EAA/B,CADA;;AAQRO,QAAAA,UAAU,EAAE,MARJ;AASRZ,QAAAA,OATQ,EAZL;;AAuBLc,MAAAA,MAAM,EAAE,KAAKC,iBAAL,EAvBH;AAwBLC,MAAAA,SAAS,EAAE,EAAEjB,QAAF,EAxBN;AAyBLkB,MAAAA,WAAW,EAAE,EAAEC,KAAK,EAAEjB,WAAT,EAzBR;AA0BLC,MAAAA,YA1BK,EAAP;;AA4BD;;AAEDa,EAAAA,iBAAiB,GAAsB;AACrC,WAAO,KAAKN,MAAL,CAAYU,oBAAZ,CAAiC,EAAEC,gBAAgB,EAAE,EAApB,EAAjC,CAAP;AACD;;AAEDC,EAAAA,aAAa,CAACC,MAAD,EAAwE;AACnF,UAAM,EAAExB,MAAF,EAAUG,WAAV,KAA0BqB,MAAhC;;AAEA,WAAO,KAAKb,MAAL,CAAYY,aAAZ,CAA0B;AAC/BE,MAAAA,IAAI,EAAE,EAAEC,KAAK,EAAE,CAAT,EAAYC,MAAM,EAAE,CAApB,EAAuBC,kBAAkB,EAAE,CAA3C,EADyB;AAE/BC,MAAAA,KAAK,EAAEC,eAAe,CAACC,iBAFQ;AAG/B/B,MAAAA,MAH+B;AAI/BG,MAAAA,WAJ+B,EAA1B,CAAP;;AAMD,GA3E4B;;;AA8E/B,OAAO,MAAM6B,CAAC,GAAGxC,aAAa,CAACI,CAAD,CAAvB;;AAEPoC,CAAC,CAACC,IAAF,CAAO,mCAAP,EAA4CC,EAA5C,CAA+CC,CAAC,IAAI;AAClD,QAAMC,UAAU,GAAGD,CAAC,CAACtC,aAAF,EAAnB;;AAEAsC,EAAAA,CAAC,CAACxB,MAAF,CAAS0B,oBAAT,CAA8BD,UAA9B;AACD,CAJD;;AAMAJ,CAAC,CAACC,IAAF,CAAO,sCAAP,EAA+CC,EAA/C,CAAkD,MAAMC,CAAN,IAAW;AAC3D,QAAMG,cAAc,GAAGH,CAAC,CAACtC,aAAF,CAAgB;AACrCK,IAAAA,OAAO,EAAE,CAAC,EAAEF,MAAM,EAAE,YAAV,EAAD,CAD4B,EAAhB,CAAvB;;;AAIA;AACAmC,EAAAA,CAAC,CAACxB,MAAF,CAAS0B,oBAAT,CAA8BC,cAA9B;;AAEA;AACA,QAAMC,aAAa,GAAGJ,CAAC,CAACtC,aAAF,CAAgB;AACpCK,IAAAA,OAAO,EAAE,EAD2B,EAAhB,CAAtB;;;AAIAiC,EAAAA,CAAC,CAACK,qBAAF,CAAwB,MAAM;AAC5BL,IAAAA,CAAC,CAACxB,MAAF,CAAS0B,oBAAT,CAA8BE,aAA9B;AACD,GAFD;AAGD,CAhBD;;AAkBAP,CAAC,CAACC,IAAF,CAAO,kCAAP;AACGT,MADH,CACUjC,QAAQ,CAAC,QAAD,EAAWE,kBAAX,CADlB;AAEGyC,EAFH,CAEM,MAAMC,CAAN,IAAW;AACb,QAAMnC,MAAwB,GAAGmC,CAAC,CAACX,MAAF,CAASxB,MAA1C;AACA,QAAMyC,IAAI,GAAG/C,qBAAqB,CAACM,MAAD,CAAlC;;AAEA,QAAMmC,CAAC,CAACO,0BAAF,CAA6BD,IAAI,CAACE,SAAlC,CAAN;;AAEA,QAAMP,UAAU,GAAGD,CAAC,CAACtC,aAAF,CAAgB,EAAEK,OAAO,EAAE,CAAC,EAAEF,MAAF,EAAD,CAAX,EAAhB,CAAnB;;AAEA,MAAIyC,IAAI,CAACG,UAAL,IAAmBH,IAAI,CAACI,KAA5B,EAAmC;AACjC;AACAV,IAAAA,CAAC,CAACxB,MAAF,CAAS0B,oBAAT,CAA8BD,UAA9B;AACD,GAHD,MAGO;AACL;AACAD,IAAAA,CAAC,CAACK,qBAAF,CAAwB,MAAM;AAC5BL,MAAAA,CAAC,CAACxB,MAAF,CAAS0B,oBAAT,CAA8BD,UAA9B;AACD,KAFD;AAGD;AACF,CAnBH;;AAqBAJ,CAAC,CAACC,IAAF,CAAO,4BAAP;AACGT,MADH,CACU;AACN,EAAErB,WAAW,EAAE,CAAf,EAAkB2C,QAAQ,EAAE,KAA5B,EADM;AAEN,EAAE3C,WAAW,EAAE,CAAf,EAAkB2C,QAAQ,EAAE,IAA5B,EAFM;AAGN,EAAE3C,WAAW,EAAE,CAAf,EAAkB2C,QAAQ,EAAE,KAA5B,EAHM;AAIN,EAAE3C,WAAW,EAAE,CAAf,EAAkB2C,QAAQ,EAAE,KAA5B,EAJM;AAKN,EAAE3C,WAAW,EAAE,CAAf,EAAkB2C,QAAQ,EAAE,IAA5B,EALM;AAMN,EAAE3C,WAAW,EAAE,CAAf,EAAkB2C,QAAQ,EAAE,KAA5B,EANM;AAON,EAAE3C,WAAW,EAAE,EAAf,EAAmB2C,QAAQ,EAAE,KAA7B,EAPM,CADV;;AAUGZ,EAVH,CAUM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEhC,WAAF,EAAe2C,QAAf,KAA4BX,CAAC,CAACX,MAApC;;AAEA,QAAMY,UAAU,GAAGD,CAAC,CAACtC,aAAF,CAAgB,EAAEM,WAAF,EAAhB,CAAnB;;AAEA,MAAI2C,QAAJ,EAAc;AACZ;AACAX,IAAAA,CAAC,CAACxB,MAAF,CAAS0B,oBAAT,CAA8BD,UAA9B;AACD,GAHD,MAGO;AACL;AACAD,IAAAA,CAAC,CAACK,qBAAF,CAAwB,MAAM;AAC5BL,MAAAA,CAAC,CAACxB,MAAF,CAAS0B,oBAAT,CAA8BD,UAA9B;AACD,KAFD;AAGD;AACF,CAxBH;;AA0BAJ,CAAC,CAACC,IAAF,CAAO,8EAAP;AACGT,MADH,CACU;AACN,EAAEuB,iBAAiB,EAAE,CAArB,EAAwBC,eAAe,EAAE,CAAzC,EAA4CF,QAAQ,EAAE,IAAtD,EADM,EACwD;AAC9D,EAAEC,iBAAiB,EAAE,CAArB,EAAwBC,eAAe,EAAE,CAAzC,EAA4CF,QAAQ,EAAE,KAAtD,EAFM,EAEyD;AAC/D,EAAEC,iBAAiB,EAAE,CAArB,EAAwBC,eAAe,EAAE,CAAzC,EAA4CF,QAAQ,EAAE,KAAtD,EAHM,CAGyD;AAHzD,CADV;AAMGZ,EANH,CAMM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEY,iBAAF,EAAqBC,eAArB,EAAsCF,QAAtC,KAAmDX,CAAC,CAACX,MAA3D;;AAEA,QAAMyB,YAAY,GAAGd,CAAC,CAACZ,aAAF,CAAgB;AACnCvB,IAAAA,MAAM,EAAE,YAD2B;AAEnCG,IAAAA,WAAW,EAAE4C,iBAFsB,EAAhB,CAArB;;AAIA,QAAMG,mBAAmB,GAAGf,CAAC,CAACZ,aAAF,CAAgB;AAC1CvB,IAAAA,MAAM,EAAE,sBADkC;AAE1CG,IAAAA,WAAW,EAAE4C,iBAF6B,EAAhB,CAA5B;;AAIA,QAAMI,uCAAuC,GAAG;AAC9CC,IAAAA,gBAAgB,EAAE;AAChB;AACEC,MAAAA,UAAU,EAAEJ,YAAY,CAACK,UAAb,EADd;AAEEC,MAAAA,SAAS,EAAE,EAAEC,CAAC,EAAE,GAAL,EAAUxB,CAAC,EAAE,GAAb,EAAkByB,CAAC,EAAE,GAArB,EAA0BC,CAAC,EAAE,GAA7B,EAFb,EADgB,CAD4B,EAAhD;;;;AAQA,QAAMC,wCAAwC,GAAG;AAC/CP,IAAAA,gBAAgB,EAAE,EAD6B;AAE/CQ,IAAAA,sBAAsB,EAAE;AACtBP,MAAAA,UAAU,EAAEH,mBAAmB,CAACI,UAApB,EADU;AAEtBO,MAAAA,cAAc,EAAE,GAFM;AAGtBC,MAAAA,YAAY,EAAE,OAHQ;AAItBC,MAAAA,gBAAgB,EAAE,CAJI;AAKtBC,MAAAA,cAAc,EAAE,OALM,EAFuB,EAAjD;;;;AAWA,QAAMC,2BAA2B,GAAG9B,CAAC,CAACxB,MAAF,CAAS0B,oBAAT;AAClCF,EAAAA,CAAC,CAACtC,aAAF,CAAgB;AACdM,IAAAA,WAAW,EAAE6C,eADC,EAAhB,CADkC,CAApC;;;AAKA,QAAMkB,4BAA4B,GAAG/B,CAAC,CAACxB,MAAF,CAAS0B,oBAAT;AACnCF,EAAAA,CAAC,CAACtC,aAAF,CAAgB;AACdK,IAAAA,OAAO,EAAE,EADK;AAEdE,IAAAA,YAAY,EAAE,EAAEJ,MAAM,EAAE,sBAAV,EAFA;AAGdG,IAAAA,WAAW,EAAE6C,eAHC,EAAhB,CADmC,CAArC;;;;AAQA,OAAK,MAAM,EAAEmB,oBAAF,EAAwBC,QAAxB,EAAX,IAAiD;AAC/C;AACED,IAAAA,oBAAoB,EAAEhB,uCADxB;AAEEiB,IAAAA,QAAQ,EAAEH,2BAFZ,EAD+C;;AAK/C;AACEE,IAAAA,oBAAoB,EAAER,wCADxB;AAEES,IAAAA,QAAQ,EAAEF,4BAFZ,EAL+C,CAAjD;;AASG;AACD,UAAMG,cAAc,GAAGlC,CAAC,CAACxB,MAAF,CAAS2D,oBAAT,EAAvB;AACA,UAAMC,UAAU,GAAGF,cAAc,CAACG,eAAf,CAA+BL,oBAA/B,CAAnB;AACAI,IAAAA,UAAU,CAACE,WAAX,CAAuBL,QAAvB;AACAG,IAAAA,UAAU,CAACG,OAAX;;AAEAvC,IAAAA,CAAC,CAACK,qBAAF,CAAwB,MAAM;AAC5B6B,MAAAA,cAAc,CAACM,MAAf;AACD,KAFD,EAEG,CAAC7B,QAFJ;AAGD;AACF,CApEH","sourcesContent":["export const description = `\ncreateRenderPipeline validation tests.\n\nTODO: review existing tests, write descriptions, and make sure tests are complete.\n      Make sure the following is covered. Consider splitting the file if too large/disjointed.\n> - various attachment problems\n>\n> - interface matching between vertex and fragment shader\n>     - superset, subset, etc.\n>\n> - vertex stage {valid, invalid}\n> - fragment stage {valid, invalid}\n> - primitive topology all possible values\n> - rasterizationState various values\n> - multisample count {0, 1, 3, 4, 8, 16, 1024}\n> - multisample mask {0, 0xFFFFFFFF}\n> - alphaToCoverage:\n>     - alphaToCoverageEnabled is { true, false } and sampleCount { = 1, = 4 }.\n>       The only failing case is (true, 1).\n>     - output SV_Coverage semantics is statically used by fragmentStage and\n>       alphaToCoverageEnabled is { true (fails), false (passes) }.\n>     - sampleMask is being used and alphaToCoverageEnabled is { true (fails), false (passes) }.\n\n`;\n\nimport { poptions } from '../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { kAllTextureFormats, kAllTextureFormatInfo } from '../../capability_info.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nclass F extends ValidationTest {\n  getDescriptor(\n    options: {\n      topology?: GPUPrimitiveTopology;\n      targets?: GPUColorTargetState[];\n      sampleCount?: number;\n      depthStencil?: GPUDepthStencilState;\n    } = {}\n  ): GPURenderPipelineDescriptor {\n    const defaultTargets: GPUColorTargetState[] = [{ format: 'rgba8unorm' }];\n    const {\n      topology = 'triangle-list',\n      targets = defaultTargets,\n      sampleCount = 1,\n      depthStencil,\n    } = options;\n\n    const format = targets.length ? targets[0].format : 'rgba8unorm';\n\n    let fragColorType;\n    let suffix;\n    if (format.endsWith('sint')) {\n      fragColorType = 'i32';\n      suffix = '';\n    } else if (format.endsWith('uint')) {\n      fragColorType = 'u32';\n      suffix = 'u';\n    } else {\n      fragColorType = 'f32';\n      suffix = '.0';\n    }\n\n    return {\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            [[builtin(position)]] var<out> Position : vec4<f32>;\n\n            [[stage(vertex)]] fn main() -> void {\n              Position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            [[location(0)]] var<out> fragColor : vec4<${fragColorType}>;\n            [[stage(fragment)]] fn main() -> void {\n              fragColor = vec4<${fragColorType}>(0${suffix}, 1${suffix}, 0${suffix}, 1${suffix});\n            }`,\n        }),\n        entryPoint: 'main',\n        targets,\n      },\n      layout: this.getPipelineLayout(),\n      primitive: { topology },\n      multisample: { count: sampleCount },\n      depthStencil,\n    };\n  }\n\n  getPipelineLayout(): GPUPipelineLayout {\n    return this.device.createPipelineLayout({ bindGroupLayouts: [] });\n  }\n\n  createTexture(params: { format: GPUTextureFormat; sampleCount: number }): GPUTexture {\n    const { format, sampleCount } = params;\n\n    return this.device.createTexture({\n      size: { width: 4, height: 4, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      format,\n      sampleCount,\n    });\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('basic_use_of_createRenderPipeline').fn(t => {\n  const descriptor = t.getDescriptor();\n\n  t.device.createRenderPipeline(descriptor);\n});\n\ng.test('at_least_one_color_state_is_required').fn(async t => {\n  const goodDescriptor = t.getDescriptor({\n    targets: [{ format: 'rgba8unorm' }],\n  });\n\n  // Control case\n  t.device.createRenderPipeline(goodDescriptor);\n\n  // Fail because lack of color states\n  const badDescriptor = t.getDescriptor({\n    targets: [],\n  });\n\n  t.expectValidationError(() => {\n    t.device.createRenderPipeline(badDescriptor);\n  });\n});\n\ng.test('color_formats_must_be_renderable')\n  .params(poptions('format', kAllTextureFormats))\n  .fn(async t => {\n    const format: GPUTextureFormat = t.params.format;\n    const info = kAllTextureFormatInfo[format];\n\n    await t.selectDeviceOrSkipTestCase(info.extension);\n\n    const descriptor = t.getDescriptor({ targets: [{ format }] });\n\n    if (info.renderable && info.color) {\n      // Succeeds when color format is renderable\n      t.device.createRenderPipeline(descriptor);\n    } else {\n      // Fails because when format is non-renderable\n      t.expectValidationError(() => {\n        t.device.createRenderPipeline(descriptor);\n      });\n    }\n  });\n\ng.test('sample_count_must_be_valid')\n  .params([\n    { sampleCount: 0, _success: false },\n    { sampleCount: 1, _success: true },\n    { sampleCount: 2, _success: false },\n    { sampleCount: 3, _success: false },\n    { sampleCount: 4, _success: true },\n    { sampleCount: 8, _success: false },\n    { sampleCount: 16, _success: false },\n  ])\n  .fn(async t => {\n    const { sampleCount, _success } = t.params;\n\n    const descriptor = t.getDescriptor({ sampleCount });\n\n    if (_success) {\n      // Succeeds when sample count is valid\n      t.device.createRenderPipeline(descriptor);\n    } else {\n      // Fails when sample count is not 4 or 1\n      t.expectValidationError(() => {\n        t.device.createRenderPipeline(descriptor);\n      });\n    }\n  });\n\ng.test('sample_count_must_be_equal_to_the_one_of_every_attachment_in_the_render_pass')\n  .params([\n    { attachmentSamples: 4, pipelineSamples: 4, _success: true }, // It is allowed to use multisampled render pass and multisampled render pipeline.\n    { attachmentSamples: 4, pipelineSamples: 1, _success: false }, // It is not allowed to use multisampled render pass and non-multisampled render pipeline.\n    { attachmentSamples: 1, pipelineSamples: 4, _success: false }, // It is not allowed to use non-multisampled render pass and multisampled render pipeline.\n  ])\n  .fn(async t => {\n    const { attachmentSamples, pipelineSamples, _success } = t.params;\n\n    const colorTexture = t.createTexture({\n      format: 'rgba8unorm',\n      sampleCount: attachmentSamples,\n    });\n    const depthStencilTexture = t.createTexture({\n      format: 'depth24plus-stencil8',\n      sampleCount: attachmentSamples,\n    });\n    const renderPassDescriptorWithoutDepthStencil = {\n      colorAttachments: [\n        {\n          attachment: colorTexture.createView(),\n          loadValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n        },\n      ],\n    };\n    const renderPassDescriptorWithDepthStencilOnly = {\n      colorAttachments: [],\n      depthStencilAttachment: {\n        attachment: depthStencilTexture.createView(),\n        depthLoadValue: 1.0,\n        depthStoreOp: 'store',\n        stencilLoadValue: 0,\n        stencilStoreOp: 'store',\n      },\n    };\n\n    const pipelineWithoutDepthStencil = t.device.createRenderPipeline(\n      t.getDescriptor({\n        sampleCount: pipelineSamples,\n      })\n    );\n    const pipelineWithDepthStencilOnly = t.device.createRenderPipeline(\n      t.getDescriptor({\n        targets: [],\n        depthStencil: { format: 'depth24plus-stencil8' },\n        sampleCount: pipelineSamples,\n      })\n    );\n\n    for (const { renderPassDescriptor, pipeline } of [\n      {\n        renderPassDescriptor: renderPassDescriptorWithoutDepthStencil,\n        pipeline: pipelineWithoutDepthStencil,\n      },\n      {\n        renderPassDescriptor: renderPassDescriptorWithDepthStencilOnly,\n        pipeline: pipelineWithDepthStencilOnly,\n      },\n    ]) {\n      const commandEncoder = t.device.createCommandEncoder();\n      const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor);\n      renderPass.setPipeline(pipeline);\n      renderPass.endPass();\n\n      t.expectValidationError(() => {\n        commandEncoder.finish();\n      }, !_success);\n    }\n  });\n"],"file":"createRenderPipeline.spec.js"}