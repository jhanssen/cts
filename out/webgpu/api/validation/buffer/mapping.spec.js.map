{"version":3,"sources":["../../../../../src/webgpu/api/validation/buffer/mapping.spec.ts"],"names":["description","pbool","poptions","params","makeTestGroup","attemptGarbageCollection","assert","unreachable","kBufferUsages","GPUConst","ValidationTest","F","testMapAsyncCall","success","rejectName","buffer","mode","offset","size","p","mapAsync","expectValidationError","ex","name","testGetMappedRangeCall","data","getMappedRange","expect","ArrayBuffer","undefined","byteLength","shouldThrow","createMappableBuffer","type","GPUMapMode","READ","device","createBuffer","usage","GPUBufferUsage","MAP_READ","WRITE","MAP_WRITE","g","kMapModeOptions","MapMode","kOffsetAlignment","kSizeAlignment","test","desc","subcases","combine","mapMode","validUsage","BufferUsage","fn","t","getErrorBuffer","destroy","mappedAtCreation","unmap","shouldReject","bufferSize","bufferUsage","COPY_DST","actualOffset","actualSize","mapOffset","mapSize","actualMapOffset","actualMapSize","offset1","size1","offset2","size2","remapBetweenCalls","range1StartsAfter2","range2StartsAfter1","disjoint","kStride","kNumStrides","stride","mapping","contents","Uint32Array","i","length"],"mappings":"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","sourcesContent":["export const description = `\nValidation tests for GPUBuffer.mapAsync, GPUBuffer.unmap and GPUBuffer.getMappedRange.\n\nTODO: review existing tests and merge with this plan:\n> - {mappedAtCreation, await mapAsync}\n>     - -> x = getMappedRange\n>     - check x.size == mapping size\n>     - -> noawait mapAsync\n>     - check x.size == mapping size\n>     - -> await\n>     - check x.size == mapping size\n>     - -> unmap\n>     - check x.size == 0\n>     - -> getMappedRange (should fail)\n> - await mapAsync -> await mapAsync -> getMappedRange\n> - {mappedAtCreation, await mapAsync} -> unmap -> unmap\n> - x = noawait mapAsync -> y = noawait mapAsync\n>     - -> getMappedRange (should fail)\n>     - -> await x\n>     - -> getMappedRange\n>     - -> shouldReject(y)\n> - noawait mapAsync -> unmap\n> - {mappedAtCreation, await mapAsync} -> x = getMappedRange -> unmap -> await mapAsync(subrange) -> y = getMappedRange\n>     - check x.size == 0, y.size == mapping size\n`;\n\nimport { pbool, poptions, params } from '../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { attemptGarbageCollection } from '../../../../common/framework/util/collect_garbage.js';\nimport { assert, unreachable } from '../../../../common/framework/util/util.js';\nimport { kBufferUsages } from '../../../capability_info.js';\nimport { GPUConst } from '../../../constants.js';\nimport { ValidationTest } from '../validation_test.js';\n\nclass F extends ValidationTest {\n  async testMapAsyncCall(\n    success: boolean,\n    rejectName: string | null,\n    buffer: GPUBuffer,\n    mode: GPUMapModeFlags,\n    offset?: number,\n    size?: number\n  ) {\n    if (success) {\n      const p = buffer.mapAsync(mode, offset, size);\n      await p;\n    } else {\n      let p: Promise<void>;\n      this.expectValidationError(() => {\n        p = buffer.mapAsync(mode, offset, size);\n      });\n      try {\n        await p!;\n        assert(rejectName === null, 'mapAsync unexpectedly passed');\n      } catch (ex) {\n        assert(rejectName === ex.name, `mapAsync rejected unexpectedly with: ${ex}`);\n      }\n    }\n  }\n\n  testGetMappedRangeCall(success: boolean, buffer: GPUBuffer, offset?: number, size?: number) {\n    if (success) {\n      const data = buffer.getMappedRange(offset, size);\n      this.expect(data instanceof ArrayBuffer);\n      if (size !== undefined) {\n        this.expect(data.byteLength === size);\n      }\n    } else {\n      this.shouldThrow('OperationError', () => {\n        buffer.getMappedRange(offset, size);\n      });\n    }\n  }\n\n  createMappableBuffer(type: GPUMapModeFlags, size: number): GPUBuffer {\n    switch (type) {\n      case GPUMapMode.READ:\n        return this.device.createBuffer({\n          size,\n          usage: GPUBufferUsage.MAP_READ,\n        });\n      case GPUMapMode.WRITE:\n        return this.device.createBuffer({\n          size,\n          usage: GPUBufferUsage.MAP_WRITE,\n        });\n      default:\n        unreachable();\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\nconst kMapModeOptions = poptions('mapMode', [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE]);\nconst kOffsetAlignment = 8;\nconst kSizeAlignment = 4;\n\ng.test('mapAsync,usage')\n  .desc(\n    `Test the usage validation for mapAsync.\n\n  For each buffer usage:\n  For GPUMapMode.READ, GPUMapMode.WRITE, and 0:\n    Test that the mapAsync call is valid iff the mapping usage is not 0 and the buffer usage\n    the mapMode flag.`\n  )\n  .subcases(() =>\n    params()\n      .combine([\n        { mapMode: GPUConst.MapMode.READ, validUsage: GPUConst.BufferUsage.MAP_READ },\n        { mapMode: GPUConst.MapMode.WRITE, validUsage: GPUConst.BufferUsage.MAP_WRITE },\n        // Using mapMode 0 is never valid, so there is no validUsage.\n        { mapMode: 0, validUsage: null },\n      ])\n      .combine(poptions('usage', kBufferUsages))\n  )\n  .fn(async t => {\n    const { mapMode, validUsage, usage } = t.params;\n\n    const buffer = t.device.createBuffer({\n      size: 16,\n      usage,\n    });\n\n    const success = usage === validUsage;\n    await t.testMapAsyncCall(success, 'OperationError', buffer, mapMode);\n  });\n\ng.test('mapAsync,invalidBuffer')\n  .desc('Test that mapAsync is an error when called on an invalid buffer.')\n  .subcases(() => kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.getErrorBuffer();\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n  });\n\ng.test('mapAsync,state,destroyed')\n  .desc('Test that mapAsync is an error when called on a destroyed buffer.')\n  .subcases(() => kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    buffer.destroy();\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n  });\n\ng.test('mapAsync,state,mappedAtCreation')\n  .desc(\n    `Test that mapAsync is an error when called on a buffer mapped at creation,\n    but succeeds after unmapping it.`\n  )\n  .subcases(() => [\n    { mapMode: GPUConst.MapMode.READ, validUsage: GPUConst.BufferUsage.MAP_READ },\n    { mapMode: GPUConst.MapMode.WRITE, validUsage: GPUConst.BufferUsage.MAP_WRITE },\n  ])\n  .fn(async t => {\n    const { mapMode, validUsage } = t.params;\n\n    const buffer = t.device.createBuffer({\n      size: 16,\n      usage: validUsage,\n      mappedAtCreation: true,\n    });\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n\n    buffer.unmap();\n    t.testMapAsyncCall(true, null, buffer, mapMode);\n  });\n\ng.test('mapAsync,state,mapped')\n  .desc(\n    `Test that mapAsync is an error when called on a mapped buffer, but succeeds\n    after unmapping it.`\n  )\n  .subcases(() => kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    await t.testMapAsyncCall(true, null, buffer, mapMode);\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n\n    buffer.unmap();\n    await t.testMapAsyncCall(true, null, buffer, mapMode);\n  });\n\ng.test('mapAsync,state,mappingPending')\n  .desc(\n    `Test that mapAsync is an error when called on a buffer that is being mapped,\n    but succeeds after the previous mapping request is cancelled.`\n  )\n  .subcases(() => kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    // Start mapping the buffer, we are going to unmap it before it resolves so it will reject\n    // the mapping promise with an AbortError.\n    t.shouldReject('AbortError', buffer.mapAsync(mapMode));\n\n    // Do the test of mapAsync while [[state]] is mapping pending. It has to be synchronous so\n    // that we can unmap the previous mapping in the same stack frame and check this one doesn't\n    // get canceled, but instead is treated as a real error.\n    t.expectValidationError(() => {\n      t.shouldReject('OperationError', buffer.mapAsync(mapMode));\n    });\n\n    // Unmap the first mapping. It should now be possible to successfully call mapAsync\n    buffer.unmap();\n    await t.testMapAsyncCall(true, null, buffer, mapMode);\n  });\n\ng.test('mapAsync,sizeUnspecifiedOOB')\n  .desc(\n    `Test that mapAsync with size unspecified rejects if offset > buffer.[[size]],\n    with various cases at the limits of the buffer size or with a misaligned offset.\n    Also test for an empty buffer.`\n  )\n  .subcases(() =>\n    params()\n      .combine(kMapModeOptions)\n      .combine([\n        // 0 size buffer.\n        { bufferSize: 0, offset: 0 },\n        { bufferSize: 0, offset: 1 },\n        { bufferSize: 0, offset: kOffsetAlignment },\n\n        // Test with a buffer that's not empty.\n        { bufferSize: 16, offset: 0 },\n        { bufferSize: 16, offset: kOffsetAlignment },\n        { bufferSize: 16, offset: 16 },\n        { bufferSize: 16, offset: 17 },\n        { bufferSize: 16, offset: 16 + kOffsetAlignment },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, bufferSize, offset } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n\n    const success = offset <= bufferSize;\n    await t.testMapAsyncCall(success, 'OperationError', buffer, mapMode, offset);\n  });\n\ng.test('mapAsync,offsetAndSizeAlignment')\n  .desc(\"Test that mapAsync fails if the alignment of offset and size isn't correct.\")\n  .subcases(() =>\n    params()\n      .combine(kMapModeOptions)\n      .combine([\n        // Valid cases, 0 and required alignments values are valid.\n        { offset: 0, size: 0 },\n        { offset: kOffsetAlignment, size: kSizeAlignment },\n\n        // Invalid case, offset isn't aligned.\n        { offset: kOffsetAlignment / 2, size: kSizeAlignment },\n\n        // Invalid case, size isn't aligned.\n        { offset: kOffsetAlignment, size: kSizeAlignment / 2 },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, offset, size } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    const success = offset % kOffsetAlignment === 0 && size % kSizeAlignment === 0;\n    await t.testMapAsyncCall(success, 'OperationError', buffer, mapMode, offset, size);\n  });\n\ng.test('mapAsync,offsetAndSizeOOB')\n  .desc('Test that mapAsync fails if offset + size is larger than the buffer size.')\n  .subcases(() =>\n    params()\n      .combine(kMapModeOptions)\n      .combine([\n        // For a 0 size buffer\n        { bufferSize: 0, offset: 0, size: 0 },\n        { bufferSize: 0, offset: 0, size: 4 },\n        { bufferSize: 0, offset: 8, size: 0 },\n\n        // For a small buffer\n        { bufferSize: 16, offset: 0, size: 16 },\n        { bufferSize: 16, offset: kOffsetAlignment, size: 16 },\n\n        { bufferSize: 16, offset: 16, size: 0 },\n        { bufferSize: 16, offset: 16, size: kSizeAlignment },\n\n        { bufferSize: 16, offset: 8, size: 0 },\n        { bufferSize: 16, offset: 8, size: 8 },\n        { bufferSize: 16, offset: 8, size: 8 + kSizeAlignment },\n\n        // For a larger buffer\n        { bufferSize: 1024, offset: 0, size: 1024 },\n        { bufferSize: 1024, offset: kOffsetAlignment, size: 1024 },\n\n        { bufferSize: 1024, offset: 1024, size: 0 },\n        { bufferSize: 1024, offset: 1024, size: kSizeAlignment },\n\n        { bufferSize: 1024, offset: 512, size: 0 },\n        { bufferSize: 1024, offset: 512, size: 512 },\n        { bufferSize: 1024, offset: 512, size: 512 + kSizeAlignment },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, bufferSize, size, offset } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n\n    const success = offset + size <= bufferSize;\n    await t.testMapAsyncCall(success, 'OperationError', buffer, mapMode, offset, size);\n  });\n\ng.test('getMappedRange,state,mapped')\n  .desc('Test that it is valid to call getMappedRange in the mapped state')\n  .subcases(() => kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    await buffer.mapAsync(mapMode);\n\n    t.testGetMappedRangeCall(true, buffer);\n  });\n\ng.test('getMappedRange,state,mappedAtCreation')\n  .desc(\n    'Test that it is valid to call getMappedRange in the mapped at creation state, for all buffer usages'\n  )\n  .subcases(() => poptions('bufferUsage', kBufferUsages))\n  .fn(async t => {\n    const { bufferUsage } = t.params;\n    const buffer = t.device.createBuffer({\n      usage: bufferUsage,\n      size: 16,\n      mappedAtCreation: true,\n    });\n\n    t.testGetMappedRangeCall(true, buffer);\n  });\n\ng.test('getMappedRange,state,unmapped')\n  .desc(\n    `Test that it is invalid to call getMappedRange in the unmapped state.\nTest for various cases of being unmapped: at creation, after a mapAsync call or after being created mapped.`\n  )\n  .fn(async t => {\n    // It is invalid to call getMappedRange when the buffer starts unmapped when created.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is unmapped after mapAsync.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.unmap();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is unmapped after mappedAtCreation.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.unmap();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n  });\n\ng.test('getMappedRange,state,destroyed')\n  .desc(\n    `Test that it is invalid to call getMappedRange in the destroyed state.\nTest for various cases of being destroyed: at creation, after a mapAsync call or after being created mapped.`\n  )\n  .fn(async t => {\n    // It is invalid to call getMappedRange when the buffer is destroyed when unmapped.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      buffer.destroy();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is destroyed when mapped.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.destroy();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is destroyed when mapped at creation.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.destroy();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n  });\n\ng.test('getMappedRange,state,mappingPending')\n  .desc('Test that it is invalid to call getMappedRange in the mappingPending state.')\n  .params(kMapModeOptions)\n  .fn(t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    /* noawait */ buffer.mapAsync(mapMode);\n    t.testGetMappedRangeCall(false, buffer);\n  });\n\ng.test('getMappedRange,offsetAndSizeAlignment')\n  .desc(\n    `Test that getMappedRange fails if the alignment of offset and size isn't correct.\n  TODO: x= {mappedAtCreation, mapAsync at {0, >0}`\n  )\n  .params(\n    params()\n      .combine(kMapModeOptions)\n      .combine([\n        // Valid cases, 0 and required alignments values are valid.\n        { offset: 0, size: 0 },\n        { offset: kOffsetAlignment, size: kSizeAlignment },\n\n        // Invalid case, offset isn't aligned.\n        { offset: kOffsetAlignment / 2, size: kSizeAlignment },\n\n        // Invalid case, size isn't aligned.\n        { offset: kOffsetAlignment, size: kSizeAlignment / 2 },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, offset, size } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    await buffer.mapAsync(mapMode);\n\n    const success = offset % kOffsetAlignment === 0 && size % kSizeAlignment === 0;\n    t.testGetMappedRangeCall(success, buffer, offset, size);\n  });\n\ng.test('getMappedRange,sizeAndOffsetOOB,forMappedAtCreation')\n  .desc(\n    `Test that getMappedRange size + offset must be less than the buffer size for a\n    buffer mapped at creation. (and offset has not constraints on its own)`\n  )\n  .subcases(() => [\n    // Tests for a zero-sized buffer, with and without a size defined.\n    { bufferSize: 0, offset: undefined, size: undefined },\n    { bufferSize: 0, offset: undefined, size: 0 },\n    { bufferSize: 0, offset: undefined, size: kSizeAlignment },\n    { bufferSize: 0, offset: 0, size: undefined },\n    { bufferSize: 0, offset: 0, size: 0 },\n    { bufferSize: 0, offset: kOffsetAlignment, size: undefined },\n    { bufferSize: 0, offset: kOffsetAlignment, size: 0 },\n\n    // Tests for a non-empty buffer, with an undefined offset.\n    { bufferSize: 80, offset: undefined, size: 80 },\n    { bufferSize: 80, offset: undefined, size: 80 + kSizeAlignment },\n\n    // Tests for a non-empty buffer, with an undefined size.\n    { bufferSize: 80, offset: undefined, size: undefined },\n    { bufferSize: 80, offset: 0, size: undefined },\n    { bufferSize: 80, offset: kOffsetAlignment, size: undefined },\n    { bufferSize: 80, offset: 80, size: undefined },\n    { bufferSize: 80, offset: 80 + kOffsetAlignment, size: undefined },\n\n    // Tests for a non-empty buffer with a size defined.\n    { bufferSize: 80, offset: 0, size: 80 },\n    { bufferSize: 80, offset: 0, size: 80 + kSizeAlignment },\n    { bufferSize: 80, offset: kOffsetAlignment, size: 80 },\n\n    { bufferSize: 80, offset: 40, size: 40 },\n    { bufferSize: 80, offset: 40 + kOffsetAlignment, size: 40 },\n    { bufferSize: 80, offset: 40, size: 40 + kSizeAlignment },\n  ])\n  .fn(t => {\n    const { bufferSize, offset, size } = t.params;\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n\n    const actualOffset = offset ?? 0;\n    const actualSize = size ?? bufferSize - actualOffset;\n\n    const success = actualOffset <= bufferSize && actualOffset + actualSize <= bufferSize;\n    t.testGetMappedRangeCall(success, buffer, offset, size);\n  });\n\ng.test('getMappedRange,sizeAndOffsetOOB,forMapped')\n  .desc('Test that getMappedRange size + offset must be less than the mapAsync range.')\n  .subcases(() =>\n    params()\n      .combine(kMapModeOptions)\n      .combine([\n        // Tests for an empty buffer, and implicit mapAsync size.\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: undefined, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: undefined, size: 0 },\n        {\n          bufferSize: 0,\n          mapOffset: 0,\n          mapSize: undefined,\n          offset: undefined,\n          size: kSizeAlignment,\n        },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: 0, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: 0, size: 0 },\n        {\n          bufferSize: 0,\n          mapOffset: 0,\n          mapSize: undefined,\n          offset: kOffsetAlignment,\n          size: undefined,\n        },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: kOffsetAlignment, size: 0 },\n\n        // Tests for an empty buffer, and explicit mapAsync size.\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: undefined, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: 0, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: 0, size: 0 },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: kOffsetAlignment, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: kOffsetAlignment, size: 0 },\n\n        // Test for a fully implicit mapAsync call\n        { bufferSize: 80, mapOffset: undefined, mapSize: undefined, offset: 0, size: 80 },\n        {\n          bufferSize: 80,\n          mapOffset: undefined,\n          mapSize: undefined,\n          offset: 0,\n          size: 80 + kSizeAlignment,\n        },\n        {\n          bufferSize: 80,\n          mapOffset: undefined,\n          mapSize: undefined,\n          offset: kOffsetAlignment,\n          size: 80,\n        },\n\n        // Test for a mapAsync call with an implicit size\n        { bufferSize: 80, mapOffset: 24, mapSize: undefined, offset: 24, size: 80 - 24 },\n        {\n          bufferSize: 80,\n          mapOffset: 24,\n          mapSize: undefined,\n          offset: 0,\n          size: 80 - 24 + kSizeAlignment,\n        },\n        {\n          bufferSize: 80,\n          mapOffset: 24,\n          mapSize: undefined,\n          offset: kOffsetAlignment,\n          size: 80 - 24,\n        },\n\n        // Test for a non-empty buffer fully mapped.\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 0, size: 80 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: kOffsetAlignment, size: 80 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 0, size: 80 + kSizeAlignment },\n\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 40, size: 40 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 40 + kOffsetAlignment, size: 40 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 40, size: 40 + kSizeAlignment },\n\n        // Test for a buffer partially mapped.\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24, size: 40 },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24 - kOffsetAlignment, size: 40 },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24 + kOffsetAlignment, size: 40 },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24, size: 40 + kSizeAlignment },\n\n        // Test for a partially mapped buffer with implicit size and offset for getMappedRange.\n        // - Buffer partially mapped in the middle\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: undefined, size: undefined },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 0, size: undefined },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24, size: undefined },\n        // - Buffer partially mapped to the end\n        { bufferSize: 80, mapOffset: 24, mapSize: undefined, offset: 24, size: undefined },\n        { bufferSize: 80, mapOffset: 24, mapSize: undefined, offset: 80, size: undefined },\n        // - Buffer partially mapped from the start\n        { bufferSize: 80, mapOffset: 0, mapSize: 64, offset: undefined, size: undefined },\n        { bufferSize: 80, mapOffset: 0, mapSize: 64, offset: undefined, size: 64 },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, bufferSize, mapOffset, mapSize, offset, size } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n    await buffer.mapAsync(mapMode, mapOffset, mapSize);\n\n    const actualMapOffset = mapOffset ?? 0;\n    const actualMapSize = mapSize ?? bufferSize - actualMapOffset;\n\n    const actualOffset = offset ?? 0;\n    const actualSize = size ?? bufferSize - actualOffset;\n\n    const success =\n      actualOffset >= actualMapOffset &&\n      actualOffset <= bufferSize &&\n      actualOffset + actualSize <= actualMapOffset + actualMapSize;\n    t.testGetMappedRangeCall(success, buffer, offset, size);\n  });\n\ng.test('getMappedRange,disjointRanges')\n  .desc('Test that the ranges asked through getMappedRange must be disjoint.')\n  .subcases(() =>\n    params()\n      .combine(pbool('remapBetweenCalls'))\n      .combine([\n        // Disjoint ranges with one that's empty.\n        { offset1: 8, size1: 0, offset2: 8, size2: 8 },\n        { offset1: 16, size1: 0, offset2: 8, size2: 8 },\n\n        { offset1: 8, size1: 8, offset2: 8, size2: 0 },\n        { offset1: 8, size1: 8, offset2: 16, size2: 0 },\n\n        // Disjoint ranges with both non-empty.\n        { offset1: 0, size1: 8, offset2: 8, size2: 8 },\n        { offset1: 16, size1: 8, offset2: 8, size2: 8 },\n\n        { offset1: 8, size1: 8, offset2: 0, size2: 8 },\n        { offset1: 8, size1: 8, offset2: 16, size2: 8 },\n\n        // Empty range contained inside another one.\n        { offset1: 16, size1: 20, offset2: 24, size2: 0 },\n        { offset1: 24, size1: 0, offset2: 16, size2: 20 },\n\n        // Ranges that overlap only partially.\n        { offset1: 16, size1: 20, offset2: 8, size2: 20 },\n        { offset1: 16, size1: 20, offset2: 32, size2: 20 },\n\n        // Ranges that include one another.\n        { offset1: 0, size1: 80, offset2: 16, size2: 20 },\n        { offset1: 16, size1: 20, offset2: 0, size2: 80 },\n      ])\n  )\n  .fn(async t => {\n    const { offset1, size1, offset2, size2, remapBetweenCalls } = t.params;\n    const buffer = t.device.createBuffer({ size: 80, usage: GPUBufferUsage.MAP_READ });\n    await buffer.mapAsync(GPUMapMode.READ);\n\n    t.testGetMappedRangeCall(true, buffer, offset1, size1);\n\n    if (remapBetweenCalls) {\n      buffer.unmap();\n      await buffer.mapAsync(GPUMapMode.READ);\n    }\n\n    const range1StartsAfter2 = offset1 >= offset2 + size2;\n    const range2StartsAfter1 = offset2 >= offset1 + size1;\n    const disjoint = range1StartsAfter2 || range2StartsAfter1;\n    const success = disjoint || remapBetweenCalls;\n\n    t.testGetMappedRangeCall(success, buffer, offset2, size2);\n  });\n\ng.test('getMappedRange,disjoinRanges_many')\n  .desc('Test getting a lot of small ranges, and that the disjoint check checks them all.')\n  .fn(async t => {\n    const kStride = 256;\n    const kNumStrides = 256;\n\n    const buffer = t.device.createBuffer({\n      size: kStride * kNumStrides,\n      usage: GPUBufferUsage.MAP_READ,\n    });\n    await buffer.mapAsync(GPUMapMode.READ);\n\n    // Get a lot of small mapped ranges.\n    for (let stride = 0; stride < kNumStrides; stride++) {\n      t.testGetMappedRangeCall(true, buffer, stride * kStride, 8);\n    }\n\n    // Check for each range it is invalid to get a range that overlaps it and check that it is valid\n    // to get ranges for the rest of the buffer.\n    for (let stride = 0; stride < kNumStrides; stride++) {\n      t.testGetMappedRangeCall(false, buffer, stride * kStride, kStride);\n      t.testGetMappedRangeCall(true, buffer, stride * kStride + 8, kStride - 8);\n    }\n  });\n\ng.test('unmap,state,unmapped')\n  .desc(\n    `Test it is invalid to call unmap on a buffer that is unmapped (at creation, or after\n    mappedAtCreation or mapAsync)`\n  )\n  .fn(async t => {\n    // It is invalid to call unmap after creation of an unmapped buffer.\n    {\n      const buffer = t.device.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ });\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n\n    // It is invalid to call unmap after unmapping a mapAsynced buffer.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.unmap();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n\n    // It is invalid to call unmap after unmapping a mappedAtCreation buffer.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.unmap();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n  });\n\ng.test('unmap,state,destroyed')\n  .desc(\n    `Test it is invalid to call unmap on a buffer that is destroyed (at creation, or after\n    mappedAtCreation or mapAsync)`\n  )\n  .fn(async t => {\n    // It is invalid to call unmap after destruction of an unmapped buffer.\n    {\n      const buffer = t.device.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ });\n      buffer.destroy();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n\n    // It is invalid to call unmap after destroying a mapAsynced buffer.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.destroy();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n\n    // It is invalid to call unmap after destroying a mappedAtCreation buffer.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.destroy();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n  });\n\ng.test('unmap,state,mappedAtCreation')\n  .desc('Test it is valid to call unmap on a buffer mapped at creation, for various usages')\n  .subcases(() => poptions('bufferUsage', kBufferUsages))\n  .fn(t => {\n    const { bufferUsage } = t.params;\n    const buffer = t.device.createBuffer({ size: 16, usage: bufferUsage, mappedAtCreation: true });\n\n    buffer.unmap();\n  });\n\ng.test('unmap,state,mapped')\n  .desc(\"Test it is valid to call unmap on a buffer that's mapped\")\n  .subcases(() => kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    await buffer.mapAsync(mapMode);\n    buffer.unmap();\n  });\n\ng.test('unmap,state,mappingPending')\n  .desc(\"Test it is valid to call unmap on a buffer that's being mapped\")\n  .subcases(() => kMapModeOptions)\n  .fn(t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    const mapping = buffer.mapAsync(mapMode);\n    t.shouldReject('AbortError', mapping);\n\n    buffer.unmap();\n  });\n\ng.test('gc_behavior,mappedAtCreation')\n  .desc(\n    \"Test that GCing the buffer while mappings are handed out doesn't invalidate them - mappedAtCreation case\"\n  )\n  .fn(async t => {\n    let buffer = null;\n    buffer = t.device.createBuffer({\n      size: 256,\n      usage: GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n\n    // Write some non-zero data to the buffer.\n    const contents = new Uint32Array(buffer.getMappedRange());\n    for (let i = 0; i < contents.length; i++) {\n      contents[i] = i;\n    }\n\n    // Trigger garbage collection that should collect the buffer (or as if it collected it)\n    // NOTE: This won't fail unless the browser immediately starts reusing the memory, or gives it\n    // back to the OS. One good option for browsers to check their logic is good is to zero-out the\n    // memory on GPUBuffer (or internal gpu::Buffer-like object) destruction.\n    buffer = null;\n    await attemptGarbageCollection();\n\n    // Use the mapping again both for read and write, it should work.\n    for (let i = 0; i < contents.length; i++) {\n      t.expect(contents[i] === i);\n      contents[i] = i + 1;\n    }\n  });\n\ng.test('gc_behavior,mapAsync')\n  .desc(\n    \"Test that GCing the buffer while mappings are handed out doesn't invalidate them - mapAsync case\"\n  )\n  .subcases(() => kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    let buffer = null;\n    buffer = t.createMappableBuffer(mapMode, 256);\n    await buffer.mapAsync(mapMode);\n\n    // Write some non-zero data to the buffer.\n    const contents = new Uint32Array(buffer.getMappedRange());\n    for (let i = 0; i < contents.length; i++) {\n      contents[i] = i;\n    }\n\n    // Trigger garbage collection that should collect the buffer (or as if it collected it)\n    // NOTE: This won't fail unless the browser immediately starts reusing the memory, or gives it\n    // back to the OS. One good option for browsers to check their logic is good is to zero-out the\n    // memory on GPUBuffer (or internal gpu::Buffer-like object) destruction.\n    buffer = null;\n    await attemptGarbageCollection();\n\n    // Use the mapping again both for read and write, it should work.\n    for (let i = 0; i < contents.length; i++) {\n      t.expect(contents[i] === i);\n      contents[i] = i + 1;\n    }\n  });\n"],"file":"mapping.spec.js"}