{"version":3,"sources":["../../../../../../src/webgpu/api/validation/queue/destroyed/query_set.spec.ts"],"names":["description","poptions","makeTestGroup","ValidationTest","EncoderType","g","test","desc","cases","subcases","fn","t","selectDeviceOrSkipTestCase","querySet","createQuerySetWithState","params","querySetState","type","count","encoder","createEncoder","encoderType","writeTimestamp","expectValidationError","queue","submit","finish","buffer","device","createBuffer","size","usage","GPUBufferUsage","QUERY_RESOLVE","createCommandEncoder","resolveQuerySet"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CATO,CAWP,SAASC,QAAT,QAAyB,mDAAzB;AACA,SAASC,aAAT,QAA8B,+CAA9B;AACA,SAASC,cAAT,QAA+B,0BAA/B;;AAEA,WAAkBC,WAAlB,C,WAAkBA,W,GAAAA,W,sCAAAA,W,sCAAAA,W,uCAAAA,W,KAAAA,W;;;;;;AAMlB,OAAO,MAAMC,CAAC,GAAGH,aAAa,CAACC,cAAD,CAAvB;;AAEPE,CAAC,CAACC,IAAF,CAAO,gBAAP;AACGC,IADH;AAEK;AACL;AACA;AACA,GALA;;AAOGC,KAPH,CAOSP,QAAQ,CAAC,aAAD,EAAgB,CAAC,UAAD,EAAa,cAAb,EAA6B,aAA7B,CAAhB,CAPjB;AAQGQ,QARH,CAQY,MAAMR,QAAQ,CAAC,eAAD,EAAkB,CAAC,OAAD,EAAU,WAAV,CAAlB,CAR1B;AASGS,EATH,CASM,MAAMC,CAAN,IAAW;AACb,QAAMA,CAAC,CAACC,0BAAF,CAA6B,iBAA7B,CAAN;;AAEA,QAAMC,QAAQ,GAAGF,CAAC,CAACG,uBAAF,CAA0BH,CAAC,CAACI,MAAF,CAASC,aAAnC,EAAkD;AACjEC,IAAAA,IAAI,EAAE,WAD2D;AAEjEC,IAAAA,KAAK,EAAE,CAF0D,EAAlD,CAAjB;;;AAKA,QAAMC,OAAO,GAAGR,CAAC,CAACS,aAAF,CAAgBT,CAAC,CAACI,MAAF,CAASM,WAAzB,CAAhB;AACAF,EAAAA,OAAO,CAACA,OAAR,CAAgBG,cAAhB,CAA+BT,QAA/B,EAAyC,CAAzC;;AAEAF,EAAAA,CAAC,CAACY,qBAAF,CAAwB,MAAM;AAC5BZ,IAAAA,CAAC,CAACa,KAAF,CAAQC,MAAR,CAAe,CAACN,OAAO,CAACO,MAAR,EAAD,CAAf;AACD,GAFD,EAEGf,CAAC,CAACI,MAAF,CAASC,aAAT,KAA2B,WAF9B;AAGD,CAvBH;;AAyBAX,CAAC,CAACC,IAAF,CAAO,iBAAP;AACGC,IADH;AAEK;AACL;AACA;AACA,GALA;;AAOGE,QAPH,CAOY,MAAMR,QAAQ,CAAC,eAAD,EAAkB,CAAC,OAAD,EAAU,WAAV,CAAlB,CAP1B;AAQGS,EARH,CAQM,MAAMC,CAAN,IAAW;AACb,QAAME,QAAQ,GAAGF,CAAC,CAACG,uBAAF,CAA0BH,CAAC,CAACI,MAAF,CAASC,aAAnC,CAAjB;;AAEA,QAAMW,MAAM,GAAGhB,CAAC,CAACiB,MAAF,CAASC,YAAT,CAAsB,EAAEC,IAAI,EAAE,CAAR,EAAWC,KAAK,EAAEC,cAAc,CAACC,aAAjC,EAAtB,CAAf;;AAEA,QAAMd,OAAO,GAAGR,CAAC,CAACiB,MAAF,CAASM,oBAAT,EAAhB;AACAf,EAAAA,OAAO,CAACgB,eAAR,CAAwBtB,QAAxB,EAAkC,CAAlC,EAAqC,CAArC,EAAwCc,MAAxC,EAAgD,CAAhD;;AAEAhB,EAAAA,CAAC,CAACY,qBAAF,CAAwB,MAAM;AAC5BZ,IAAAA,CAAC,CAACa,KAAF,CAAQC,MAAR,CAAe,CAACN,OAAO,CAACO,MAAR,EAAD,CAAf;AACD,GAFD,EAEGf,CAAC,CAACI,MAAF,CAASC,aAAT,KAA2B,WAF9B;AAGD,CAnBH","sourcesContent":["export const description = `\nTests using a destroyed query set on a queue.\n\n- used in {resolveQuerySet, timestamp {compute, render, non-pass},\n    pipeline statistics {compute, render}, occlusion}\n- x= {destroyed, not destroyed (control case)}\n\nTODO: implement. (Search for other places some of these cases may have already been tested.)\nConsider whether these tests should be distributed throughout the suite, instead of centralized.\n`;\n\nimport { poptions } from '../../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { ValidationTest } from '../../validation_test.js';\n\nexport const enum EncoderType {\n  CommandEncoder = 'CommandEncoder',\n  ComputeEncoder = 'ComputeEncoder',\n  RenderEncoder = 'RenderEncoder',\n}\n\nexport const g = makeTestGroup(ValidationTest);\n\ng.test('writeTimestamp')\n  .desc(\n    `\nTests that use a destroyed query set in writeTimestamp on {non-pass, compute, render} encoder.\n- x= {destroyed, not destroyed (control case)}\n  `\n  )\n  .cases(poptions('encoderType', ['non-pass', 'compute pass', 'render pass'] as const))\n  .subcases(() => poptions('querySetState', ['valid', 'destroyed'] as const))\n  .fn(async t => {\n    await t.selectDeviceOrSkipTestCase('timestamp-query');\n\n    const querySet = t.createQuerySetWithState(t.params.querySetState, {\n      type: 'timestamp',\n      count: 2,\n    });\n\n    const encoder = t.createEncoder(t.params.encoderType);\n    encoder.encoder.writeTimestamp(querySet, 0);\n\n    t.expectValidationError(() => {\n      t.queue.submit([encoder.finish()]);\n    }, t.params.querySetState === 'destroyed');\n  });\n\ng.test('resolveQuerySet')\n  .desc(\n    `\nTests that use a destroyed query set in resolveQuerySet.\n- x= {destroyed, not destroyed (control case)}\n  `\n  )\n  .subcases(() => poptions('querySetState', ['valid', 'destroyed'] as const))\n  .fn(async t => {\n    const querySet = t.createQuerySetWithState(t.params.querySetState);\n\n    const buffer = t.device.createBuffer({ size: 8, usage: GPUBufferUsage.QUERY_RESOLVE });\n\n    const encoder = t.device.createCommandEncoder();\n    encoder.resolveQuerySet(querySet, 0, 1, buffer, 0);\n\n    t.expectValidationError(() => {\n      t.queue.submit([encoder.finish()]);\n    }, t.params.querySetState === 'destroyed');\n  });\n"],"file":"query_set.spec.js"}