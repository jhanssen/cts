{"version":3,"sources":["../../../../src/webgpu/api/validation/buffer_mapping.spec.ts"],"names":["description","pbool","poptions","params","makeTestGroup","unreachable","kBufferUsages","GPUConst","ValidationTest","F","testMapAsyncCall","success","rejectName","buffer","mode","offset","size","p","mapAsync","shouldResolve","expectValidationError","shouldReject","testGetMappedRangeCall","data","getMappedRange","expect","ArrayBuffer","undefined","byteLength","shouldThrow","createMappableBuffer","type","GPUMapMode","READ","device","createBuffer","usage","GPUBufferUsage","MAP_READ","WRITE","MAP_WRITE","g","kMapModeOptions","MapMode","kOffsetAlignment","kSizeAlignment","test","desc","combine","mapMode","validUsage","BufferUsage","fn","t","getErrorBuffer","destroy","mappedAtCreation","unmap","bufferSize","bufferUsage","COPY_DST","actualOffset","actualSize","mapOffset","mapSize","actualMapOffset","actualMapSize","offset1","size1","offset2","size2","remapBetweenCalls","range1StartsAfter2","range2StartsAfter1","disjoint","kStride","kNumStrides","stride","mapping"],"mappings":"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","sourcesContent":["export const description = `\nValidation tests for GPUBuffer.mapAsync, GPUBuffer.unmap and GPUBuffer.getMappedRange.\n`;\n\nimport { pbool, poptions, params } from '../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { unreachable } from '../../../common/framework/util/util.js';\nimport { kBufferUsages } from '../../capability_info.js';\nimport { GPUConst } from '../../constants.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nclass F extends ValidationTest {\n  async testMapAsyncCall(\n    success: boolean,\n    rejectName: string | null,\n    buffer: GPUBuffer,\n    mode: GPUMapModeFlags,\n    offset?: number,\n    size?: number\n  ) {\n    if (success) {\n      const p = buffer.mapAsync(mode, offset, size);\n      await p;\n      this.shouldResolve(p);\n    } else {\n      this.expectValidationError(async () => {\n        const p = buffer.mapAsync(mode, offset, size);\n        await p;\n        this.shouldReject(rejectName!, p);\n      });\n    }\n  }\n\n  testGetMappedRangeCall(success: boolean, buffer: GPUBuffer, offset?: number, size?: number) {\n    if (success) {\n      const data = buffer.getMappedRange(offset, size);\n      this.expect(data instanceof ArrayBuffer);\n      if (size !== undefined) {\n        this.expect(data.byteLength === size);\n      }\n    } else {\n      this.shouldThrow('OperationError', () => {\n        buffer.getMappedRange(offset, size);\n      });\n    }\n  }\n\n  createMappableBuffer(type: GPUMapModeFlags, size: number): GPUBuffer {\n    switch (type) {\n      case GPUMapMode.READ:\n        return this.device.createBuffer({\n          size,\n          usage: GPUBufferUsage.MAP_READ,\n        });\n      case GPUMapMode.WRITE:\n        return this.device.createBuffer({\n          size,\n          usage: GPUBufferUsage.MAP_WRITE,\n        });\n      default:\n        unreachable();\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\nconst kMapModeOptions = poptions('mapMode', [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE]);\nconst kOffsetAlignment = 8;\nconst kSizeAlignment = 4;\n\ng.test('mapAsync,usage')\n  .desc(\n    `Test the usage validation for mapAsync.\n\n  For each buffer usage:\n  For GPUMapMode.READ, GPUMapMode.WRITE, and 0:\n    Test that the mapAsync call is valid iff the mapping usage is not 0 and the buffer usage\n    the mapMode flag.`\n  )\n  .params(\n    params()\n      .combine([\n        { mapMode: GPUConst.MapMode.READ, validUsage: GPUConst.BufferUsage.MAP_READ },\n        { mapMode: GPUConst.MapMode.WRITE, validUsage: GPUConst.BufferUsage.MAP_WRITE },\n        // Using mapMode 0 is never valid, so there is no validUsage.\n        { mapMode: 0, validUsage: null },\n      ])\n      .combine(poptions('usage', kBufferUsages))\n  )\n  .fn(async t => {\n    const { mapMode, validUsage, usage } = t.params;\n\n    const buffer = t.device.createBuffer({\n      size: 16,\n      usage,\n    });\n\n    const success = usage === validUsage;\n    await t.testMapAsyncCall(success, 'OperationError', buffer, mapMode);\n  });\n\ng.test('mapAsync,invalidBuffer')\n  .desc('Test that mapAsync is an error when called on an invalid buffer.')\n  .params(kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.getErrorBuffer();\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n  });\n\ng.test('mapAsync_,state,destroyed')\n  .desc('Test that mapAsync is an error when called on a destroyed buffer.')\n  .params(kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    buffer.destroy();\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n  });\n\ng.test('mapAsync,state,mappedAtCreation')\n  .desc(\n    `Test that mapAsync is an error when called on a buffer mapped at creation,\n    but succeeds after unmapping it.`\n  )\n  .params([\n    { mapMode: GPUConst.MapMode.READ, validUsage: GPUConst.BufferUsage.MAP_READ },\n    { mapMode: GPUConst.MapMode.WRITE, validUsage: GPUConst.BufferUsage.MAP_WRITE },\n  ])\n  .fn(async t => {\n    const { mapMode, validUsage } = t.params;\n\n    const buffer = t.device.createBuffer({\n      size: 16,\n      usage: validUsage,\n      mappedAtCreation: true,\n    });\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n\n    buffer.unmap();\n    t.testMapAsyncCall(true, null, buffer, mapMode);\n  });\n\ng.test('mapAsync,state,mapped')\n  .desc(\n    `Test that mapAsync is an error when called on a mapped buffer, but succeeds\n    after unmapping it.`\n  )\n  .params(kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    await t.testMapAsyncCall(true, null, buffer, mapMode);\n    await t.testMapAsyncCall(false, 'OperationError', buffer, mapMode);\n\n    buffer.unmap();\n    await t.testMapAsyncCall(true, null, buffer, mapMode);\n  });\n\ng.test('mapAsync,state,mappingPending')\n  .desc(\n    `Test that mapAsync is an error when called on a buffer that is being mapped,\n    but succeeds after the previous mapping request is cancelled.`\n  )\n  .params(kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    // Start mapping the buffer, we are going to unmap it before it resolves so it will reject\n    // the mapping promise with an AbortError.\n    t.shouldReject('AbortError', buffer.mapAsync(mapMode));\n\n    // Do the test of mapAsync while [[state]] is mapping pending. It has to be synchronous so\n    // that we can unmap the previous mapping in the same stack frame and check this one doesn't\n    // get canceled, but instead is treated as a real error.\n    t.expectValidationError(() => {\n      t.shouldReject('OperationError', buffer.mapAsync(mapMode));\n    });\n\n    // Unmap the first mapping. It should now be possible to successfully call mapAsync\n    buffer.unmap();\n    await t.testMapAsyncCall(true, null, buffer, mapMode);\n  });\n\ng.test('mapAsync,sizeUnspecifiedOOB')\n  .desc(\n    `Test that mapAsync with size unspecified rejects if offset > buffer.[[size]],\n    with various cases at the limits of the buffer size or with a misaligned offset.\n    Also test for an empty buffer.`\n  )\n  .params(\n    params()\n      .combine(kMapModeOptions)\n      .combine([\n        // 0 size buffer.\n        { bufferSize: 0, offset: 0 },\n        { bufferSize: 0, offset: 1 },\n        { bufferSize: 0, offset: kOffsetAlignment },\n\n        // Test with a buffer that's not empty.\n        { bufferSize: 16, offset: 0 },\n        { bufferSize: 16, offset: kOffsetAlignment },\n        { bufferSize: 16, offset: 16 },\n        { bufferSize: 16, offset: 17 },\n        { bufferSize: 16, offset: 16 + kOffsetAlignment },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, bufferSize, offset } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n\n    const success = offset <= bufferSize;\n    await t.testMapAsyncCall(success, 'OperationError', buffer, mapMode, offset);\n  });\n\ng.test('mapAsync,offsetAndSizeAlignment')\n  .desc(\"Test that mapAsync fails if the alignment of offset and size isn't correct.\")\n  .params(\n    params()\n      .combine(kMapModeOptions)\n      .combine([\n        // Valid cases, 0 and required alignments values are valid.\n        { offset: 0, size: 0 },\n        { offset: kOffsetAlignment, size: kSizeAlignment },\n\n        // Invalid case, offset isn't aligned.\n        { offset: kOffsetAlignment / 2, size: kSizeAlignment },\n\n        // Invalid case, size isn't aligned.\n        { offset: kOffsetAlignment, size: kSizeAlignment / 2 },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, offset, size } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    const success = offset % kOffsetAlignment === 0 && size % kSizeAlignment === 0;\n    await t.testMapAsyncCall(success, 'OperationError', buffer, mapMode, offset, size);\n  });\n\ng.test('mapAsync,offsetAndSizeOOB')\n  .desc('Test that mapAsync fails if offset + size is larger than the buffer size.')\n  .params(\n    params()\n      .combine(kMapModeOptions)\n      .combine([\n        // For a 0 size buffer\n        { bufferSize: 0, offset: 0, size: 0 },\n        { bufferSize: 0, offset: 0, size: 4 },\n        { bufferSize: 0, offset: 8, size: 0 },\n\n        // For a small buffer\n        { bufferSize: 16, offset: 0, size: 16 },\n        { bufferSize: 16, offset: kOffsetAlignment, size: 16 },\n\n        { bufferSize: 16, offset: 16, size: 0 },\n        { bufferSize: 16, offset: 16, size: kSizeAlignment },\n\n        { bufferSize: 16, offset: 8, size: 0 },\n        { bufferSize: 16, offset: 8, size: 8 },\n        { bufferSize: 16, offset: 8, size: 8 + kSizeAlignment },\n\n        // For a larger buffer\n        { bufferSize: 1024, offset: 0, size: 1024 },\n        { bufferSize: 1024, offset: kOffsetAlignment, size: 1024 },\n\n        { bufferSize: 1024, offset: 1024, size: 0 },\n        { bufferSize: 1024, offset: 1024, size: kSizeAlignment },\n\n        { bufferSize: 1024, offset: 512, size: 0 },\n        { bufferSize: 1024, offset: 512, size: 512 },\n        { bufferSize: 1024, offset: 512, size: 512 + kSizeAlignment },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, bufferSize, size, offset } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n\n    const success = offset + size <= bufferSize;\n    await t.testMapAsyncCall(success, 'OperationError', buffer, mapMode, offset, size);\n  });\n\ng.test('getMappedRange,state,mapped')\n  .desc('Test that it is valid to call getMappedRange in the mapped state')\n  .params(kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    await buffer.mapAsync(mapMode);\n\n    t.testGetMappedRangeCall(true, buffer);\n  });\n\ng.test('getMappedRange,state,mappedAtCreation')\n  .desc(\n    'Test that it is valid to call getMappedRange in the mapped at creation state, for all buffer usages'\n  )\n  .params(poptions('bufferUsage', kBufferUsages))\n  .fn(async t => {\n    const { bufferUsage } = t.params;\n    const buffer = t.device.createBuffer({\n      usage: bufferUsage,\n      size: 16,\n      mappedAtCreation: true,\n    });\n\n    t.testGetMappedRangeCall(true, buffer);\n  });\n\ng.test('getMappedRange,state,unmapped')\n  .desc(\n    `Test that it is invalid to call getMappedRange in the unmapped state.\nTest for various cases of being unmapped: at creation, after a mapAsync call or after being created mapped.`\n  )\n  .fn(async t => {\n    // It is invalid to call getMappedRange when the buffer starts unmapped when created.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is unmapped after mapAsync.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.unmap();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is unmapped after mappedAtCreation.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.unmap();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n  });\n\ng.test('getMappedRange,state,destroyed')\n  .desc(\n    `Test that it is invalid to call getMappedRange in the destroyed state.\nTest for various cases of being destroyed: at creation, after a mapAsync call or after being created mapped.`\n  )\n  .fn(async t => {\n    // It is invalid to call getMappedRange when the buffer is destroyed when unmapped.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      buffer.destroy();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is destroyed when mapped.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.destroy();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n\n    // It is invalid to call getMappedRange when the buffer is destroyed when mapped at creation.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.destroy();\n      t.testGetMappedRangeCall(false, buffer);\n    }\n  });\n\ng.test('getMappedRange,state,mappingPending')\n  .desc('Test that it is invalid to call getMappedRange in the mappingPending state.')\n  .params(kMapModeOptions)\n  .fn(t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    buffer.mapAsync(mapMode);\n    t.testGetMappedRangeCall(false, buffer);\n  });\n\ng.test('getMappedRange,offsetAndSizeAlignment')\n  .desc(\"Test that getMappedRange fails if the alignment of offset and size isn't correct.\")\n  .params(\n    params()\n      .combine(kMapModeOptions)\n      .combine([\n        // Valid cases, 0 and required alignments values are valid.\n        { offset: 0, size: 0 },\n        { offset: kOffsetAlignment, size: kSizeAlignment },\n\n        // Invalid case, offset isn't aligned.\n        { offset: kOffsetAlignment / 2, size: kSizeAlignment },\n\n        // Invalid case, size isn't aligned.\n        { offset: kOffsetAlignment, size: kSizeAlignment / 2 },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, offset, size } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n    await buffer.mapAsync(mapMode);\n\n    const success = offset % kOffsetAlignment === 0 && size % kSizeAlignment === 0;\n    await t.testGetMappedRangeCall(success, buffer, offset, size);\n  });\n\ng.test('getMappedRange,sizeAndOffsetOOB,forMappedAtCreation')\n  .desc(\n    `Test that getMappedRange size + offset must be less than the buffer size for a\n    buffer mapped at creation. (and offset has not constraints on its own)`\n  )\n  .params([\n    // Tests for a zero-sized buffer, with and without a size defined.\n    { bufferSize: 0, offset: undefined, size: undefined },\n    { bufferSize: 0, offset: undefined, size: 0 },\n    { bufferSize: 0, offset: undefined, size: kSizeAlignment },\n    { bufferSize: 0, offset: 0, size: undefined },\n    { bufferSize: 0, offset: 0, size: 0 },\n    { bufferSize: 0, offset: kOffsetAlignment, size: undefined },\n    { bufferSize: 0, offset: kOffsetAlignment, size: 0 },\n\n    // Tests for a non-empty buffer, with an undefined offset.\n    { bufferSize: 80, offset: undefined, size: 80 },\n    { bufferSize: 80, offset: undefined, size: 80 + kSizeAlignment },\n\n    // Tests for a non-empty buffer, with an undefined size.\n    { bufferSize: 80, offset: undefined, size: undefined },\n    { bufferSize: 80, offset: 0, size: undefined },\n    { bufferSize: 80, offset: kOffsetAlignment, size: undefined },\n    { bufferSize: 80, offset: 80, size: undefined },\n    { bufferSize: 80, offset: 80 + kOffsetAlignment, size: undefined },\n\n    // Tests for a non-empty buffer with a size defined.\n    { bufferSize: 80, offset: 0, size: 80 },\n    { bufferSize: 80, offset: 0, size: 80 + kSizeAlignment },\n    { bufferSize: 80, offset: kOffsetAlignment, size: 80 },\n\n    { bufferSize: 80, offset: 40, size: 40 },\n    { bufferSize: 80, offset: 40 + kOffsetAlignment, size: 40 },\n    { bufferSize: 80, offset: 40, size: 40 + kSizeAlignment },\n  ])\n  .fn(t => {\n    const { bufferSize, offset, size } = t.params;\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n\n    const actualOffset = offset ?? 0;\n    const actualSize = size ?? bufferSize - actualOffset;\n\n    const success = actualOffset <= bufferSize && actualOffset + actualSize <= bufferSize;\n    t.testGetMappedRangeCall(success, buffer, offset, size);\n  });\n\ng.test('getMappedRange,sizeAndOffsetOOB,forMapped')\n  .desc(\n    `Test that getMappedRange size + offset must be less than the buffer size for a\n    buffer mapped.`\n  )\n  .params(\n    params()\n      .combine(kMapModeOptions)\n      .combine([\n        // Tests for an empty buffer, and implicit mapAsync size.\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: undefined, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: undefined, size: 0 },\n        {\n          bufferSize: 0,\n          mapOffset: 0,\n          mapSize: undefined,\n          offset: undefined,\n          size: kSizeAlignment,\n        },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: 0, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: 0, size: 0 },\n        {\n          bufferSize: 0,\n          mapOffset: 0,\n          mapSize: undefined,\n          offset: kOffsetAlignment,\n          size: undefined,\n        },\n        { bufferSize: 0, mapOffset: 0, mapSize: undefined, offset: kOffsetAlignment, size: 0 },\n\n        // Tests for an empty buffer, and explicit mapAsync size.\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: undefined, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: 0, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: 0, size: 0 },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: kOffsetAlignment, size: undefined },\n        { bufferSize: 0, mapOffset: 0, mapSize: 0, offset: kOffsetAlignment, size: 0 },\n\n        // Test for a fully implicit mapAsync call\n        { bufferSize: 80, mapOffset: undefined, mapSize: undefined, offset: 0, size: 80 },\n        {\n          bufferSize: 80,\n          mapOffset: undefined,\n          mapSize: undefined,\n          offset: 0,\n          size: 80 + kSizeAlignment,\n        },\n        {\n          bufferSize: 80,\n          mapOffset: undefined,\n          mapSize: undefined,\n          offset: kOffsetAlignment,\n          size: 80,\n        },\n\n        // Test for a mapAsync call with an implicit size\n        { bufferSize: 80, mapOffset: 24, mapSize: undefined, offset: 24, size: 80 - 24 },\n        {\n          bufferSize: 80,\n          mapOffset: 24,\n          mapSize: undefined,\n          offset: 0,\n          size: 80 - 24 + kSizeAlignment,\n        },\n        {\n          bufferSize: 80,\n          mapOffset: 24,\n          mapSize: undefined,\n          offset: kOffsetAlignment,\n          size: 80 - 24,\n        },\n\n        // Test for a non-empty buffer fully mapped.\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 0, size: 80 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: kOffsetAlignment, size: 80 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 0, size: 80 + kSizeAlignment },\n\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 40, size: 40 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 40 + kOffsetAlignment, size: 40 },\n        { bufferSize: 80, mapOffset: 0, mapSize: 80, offset: 40, size: 40 + kSizeAlignment },\n\n        // Test for a buffer partially mapped.\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24, size: 40 },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24 - kOffsetAlignment, size: 40 },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24 + kOffsetAlignment, size: 40 },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24, size: 40 + kSizeAlignment },\n\n        // Test for a partially mapped buffer with implicit size and offset for getMappedRange.\n        // - Buffer partially mapped in the middle\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: undefined, size: undefined },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 0, size: undefined },\n        { bufferSize: 80, mapOffset: 24, mapSize: 40, offset: 24, size: undefined },\n        // - Buffer partially mapped to the end\n        { bufferSize: 80, mapOffset: 24, mapSize: undefined, offset: 24, size: undefined },\n        { bufferSize: 80, mapOffset: 24, mapSize: undefined, offset: 80, size: undefined },\n        // - Buffer partially mapped from the start\n        { bufferSize: 80, mapOffset: 0, mapSize: 64, offset: undefined, size: undefined },\n        { bufferSize: 80, mapOffset: 0, mapSize: 64, offset: undefined, size: 64 },\n      ])\n  )\n  .fn(async t => {\n    const { mapMode, bufferSize, mapOffset, mapSize, offset, size } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, bufferSize);\n    await buffer.mapAsync(mapMode, mapOffset, mapSize);\n\n    const actualMapOffset = mapOffset ?? 0;\n    const actualMapSize = mapSize ?? bufferSize - actualMapOffset;\n\n    const actualOffset = offset ?? 0;\n    const actualSize = size ?? bufferSize - actualOffset;\n\n    const success =\n      actualOffset >= actualMapOffset &&\n      actualOffset <= bufferSize &&\n      actualOffset + actualSize <= actualMapOffset + actualMapSize;\n    t.testGetMappedRangeCall(success, buffer, offset, size);\n  });\n\ng.test('getMappedRange,disjointRanges')\n  .desc('Test that the ranges asked through getMappedRange must be disjoint.')\n  .params(\n    params()\n      .combine(pbool('remapBetweenCalls'))\n      .combine([\n        // Disjoint ranges with one that's empty.\n        { offset1: 8, size1: 0, offset2: 8, size2: 8 },\n        { offset1: 16, size1: 0, offset2: 8, size2: 8 },\n\n        { offset1: 8, size1: 8, offset2: 8, size2: 0 },\n        { offset1: 8, size1: 8, offset2: 16, size2: 0 },\n\n        // Disjoint ranges with both non-empty.\n        { offset1: 0, size1: 8, offset2: 8, size2: 8 },\n        { offset1: 16, size1: 8, offset2: 8, size2: 8 },\n\n        { offset1: 8, size1: 8, offset2: 0, size2: 8 },\n        { offset1: 8, size1: 8, offset2: 16, size2: 8 },\n\n        // Empty range contained inside another one.\n        { offset1: 16, size1: 20, offset2: 24, size2: 0 },\n        { offset1: 24, size1: 0, offset2: 16, size2: 20 },\n\n        // Ranges that overlap only partially.\n        { offset1: 16, size1: 20, offset2: 8, size2: 20 },\n        { offset1: 16, size1: 20, offset2: 32, size2: 20 },\n\n        // Ranges that include one another.\n        { offset1: 0, size1: 80, offset2: 16, size2: 20 },\n        { offset1: 16, size1: 20, offset2: 0, size2: 80 },\n      ])\n  )\n  .fn(async t => {\n    const { offset1, size1, offset2, size2, remapBetweenCalls } = t.params;\n    const buffer = t.device.createBuffer({ size: 80, usage: GPUBufferUsage.MAP_READ });\n    await buffer.mapAsync(GPUMapMode.READ);\n\n    t.testGetMappedRangeCall(true, buffer, offset1, size1);\n\n    if (remapBetweenCalls) {\n      buffer.unmap();\n      await buffer.mapAsync(GPUMapMode.READ);\n    }\n\n    const range1StartsAfter2 = offset1 >= offset2 + size2;\n    const range2StartsAfter1 = offset2 >= offset1 + size1;\n    const disjoint = range1StartsAfter2 || range2StartsAfter1;\n    const success = disjoint || remapBetweenCalls;\n\n    t.testGetMappedRangeCall(success, buffer, offset2, size2);\n  });\n\ng.test('getMappedRange,disjoinRanges_many')\n  .desc('Test getting a lot of small ranges, and that the disjoint check checks them all.')\n  .fn(async t => {\n    const kStride = 256;\n    const kNumStrides = 256;\n\n    const buffer = t.device.createBuffer({\n      size: kStride * kNumStrides,\n      usage: GPUBufferUsage.MAP_READ,\n    });\n    await buffer.mapAsync(GPUMapMode.READ);\n\n    // Get a lot of small mapped ranges.\n    for (let stride = 0; stride < kNumStrides; stride++) {\n      t.testGetMappedRangeCall(true, buffer, stride * kStride, 8);\n    }\n\n    // Check for each range it is invalid to get a range that overlaps it and check that it is valid\n    // to get ranges for the rest of the buffer.\n    for (let stride = 0; stride < kNumStrides; stride++) {\n      t.testGetMappedRangeCall(false, buffer, stride * kStride, kStride);\n      t.testGetMappedRangeCall(true, buffer, stride * kStride + 8, kStride - 8);\n    }\n  });\n\ng.test('unmap,state,unmapped')\n  .desc(\n    `Test it is invalid to call unmap on a buffer that is unmapped (at creation, or after\n    mappedAtCreation or mapAsync)`\n  )\n  .fn(async t => {\n    // It is invalid to call unmap after creation of an unmapped buffer.\n    {\n      const buffer = t.device.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ });\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n\n    // It is invalid to call unmap after unmapping a mapAsynced buffer.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.unmap();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n\n    // It is invalid to call unmap after unmapping a mappedAtCreation buffer.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.unmap();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n  });\n\ng.test('unmap,state,destroyed')\n  .desc(\n    `Test it is invalid to call unmap on a buffer that is destroyed (at creation, or after\n    mappedAtCreation or mapAsync)`\n  )\n  .fn(async t => {\n    // It is invalid to call unmap after destruction of an unmapped buffer.\n    {\n      const buffer = t.device.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ });\n      buffer.destroy();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n\n    // It is invalid to call unmap after destroying a mapAsynced buffer.\n    {\n      const buffer = t.createMappableBuffer(GPUMapMode.READ, 16);\n      await buffer.mapAsync(GPUMapMode.READ);\n      buffer.destroy();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n\n    // It is invalid to call unmap after destroying a mappedAtCreation buffer.\n    {\n      const buffer = t.device.createBuffer({\n        usage: GPUBufferUsage.MAP_READ,\n        size: 16,\n        mappedAtCreation: true,\n      });\n      buffer.destroy();\n      t.expectValidationError(() => {\n        buffer.unmap();\n      });\n    }\n  });\n\ng.test('unmap,state,mappedAtCreation')\n  .desc('Test it is valid to call unmap on a buffer mapped at creation, for various usages')\n  .params(poptions('bufferUsage', kBufferUsages))\n  .fn(t => {\n    const { bufferUsage } = t.params;\n    const buffer = t.device.createBuffer({ size: 16, usage: bufferUsage, mappedAtCreation: true });\n\n    buffer.unmap();\n  });\n\ng.test('unmap,state,mapped')\n  .desc(\"Test it is valid to call unmap on a buffer that's mapped\")\n  .params(kMapModeOptions)\n  .fn(async t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    await buffer.mapAsync(mapMode);\n    buffer.unmap();\n  });\n\ng.test('unmap,state,mappingPending')\n  .desc(\"Test it is valid to call unmap on a buffer that's being mapped\")\n  .params(kMapModeOptions)\n  .fn(t => {\n    const { mapMode } = t.params;\n    const buffer = t.createMappableBuffer(mapMode, 16);\n\n    const mapping = buffer.mapAsync(mapMode);\n    t.shouldReject('AbortError', mapping);\n\n    buffer.unmap();\n  });\n"],"file":"buffer_mapping.spec.js"}