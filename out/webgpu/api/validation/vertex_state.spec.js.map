{"version":3,"sources":["../../../../src/webgpu/api/validation/vertex_state.spec.ts"],"names":["description","params","pbool","poptions","makeTestGroup","kMaxVertexAttributes","kMaxVertexBufferArrayStride","kMaxVertexBuffers","kVertexFormats","kVertexFormatInfo","ValidationTest","VERTEX_SHADER_CODE_WITH_NO_INPUT","addTestAttributes","attributes","testAttribute","testAttributeAtStart","extraAttributeCount","extraAttributeSkippedLocations","currentLocation","extraAttribsAdded","includes","push","format","shaderLocation","offset","unshift","F","getDescriptor","buffers","vertexShaderCode","descriptor","vertex","module","device","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","testVertexState","success","vertexShader","vsModule","fsModule","expectValidationError","createRenderPipeline","generateTestVertexShader","inputs","interfaces","body","count","input","location","type","g","test","desc","subcases","combine","fn","t","lastEmpty","vertexBuffers","i","arrayStride","attribCount","attribsPerBuffer","attribsAdded","targetCount","Math","min","length","vertexBufferIndex","testShaderLocation","vertexBufferIndexA","vertexBufferIndexB","testAttributeAtStartA","testAttributeAtStartB","shaderLocationA","shaderLocationB","vertexBufferAttributes","attributesA","attributesB","testLocation","shader","cases","expand","p","shaderBaseType","shaderType","requiredBaseType","sint","uint","snorm","unorm","float","bytesPerComponent","componentCount","formatSize","halfAlignment","floor","Set","offsetsToTest","formatInfo","limit","formats"],"mappings":"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","sourcesContent":["export const description = `vertexState validation tests.`;\n\nimport { params, pbool, poptions } from '../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport {\n  kMaxVertexAttributes,\n  kMaxVertexBufferArrayStride,\n  kMaxVertexBuffers,\n  kVertexFormats,\n  kVertexFormatInfo,\n} from '../../capability_info.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nconst VERTEX_SHADER_CODE_WITH_NO_INPUT = `\n  [[stage(vertex)]] fn main() -> [[builtin(position)]] vec4<f32> {\n    return vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  }\n`;\n\nfunction addTestAttributes(\n  attributes: GPUVertexAttribute[],\n  {\n    testAttribute,\n    testAttributeAtStart = true,\n    extraAttributeCount = 0,\n    extraAttributeSkippedLocations = [],\n  }: {\n    testAttribute?: GPUVertexAttribute;\n    testAttributeAtStart?: boolean;\n    extraAttributeCount?: Number;\n    extraAttributeSkippedLocations?: Number[];\n  }\n) {\n  // Add a bunch of dummy attributes each with a different location such that none of the locations\n  // are in extraAttributeSkippedLocations\n  let currentLocation = 0;\n  let extraAttribsAdded = 0;\n  while (extraAttribsAdded !== extraAttributeCount) {\n    if (extraAttributeSkippedLocations.includes(currentLocation)) {\n      currentLocation++;\n      continue;\n    }\n\n    attributes.push({ format: 'float32', shaderLocation: currentLocation, offset: 0 });\n    currentLocation++;\n    extraAttribsAdded++;\n  }\n\n  // Add the test attribute at the start or the end of the attributes.\n  if (testAttribute) {\n    if (testAttributeAtStart) {\n      attributes.unshift(testAttribute);\n    } else {\n      attributes.push(testAttribute);\n    }\n  }\n}\n\nclass F extends ValidationTest {\n  getDescriptor(\n    buffers: Iterable<GPUVertexBufferLayout>,\n    vertexShaderCode: string\n  ): GPURenderPipelineDescriptor {\n    const descriptor: GPURenderPipelineDescriptor = {\n      vertex: {\n        module: this.device.createShaderModule({ code: vertexShaderCode }),\n        entryPoint: 'main',\n        buffers,\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            [[stage(fragment)]] fn main() -> [[location(0)]] vec4<f32> {\n              return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: { topology: 'triangle-list' },\n    };\n    return descriptor;\n  }\n\n  testVertexState(\n    success: boolean,\n    buffers: Iterable<GPUVertexBufferLayout>,\n    vertexShader: string = VERTEX_SHADER_CODE_WITH_NO_INPUT\n  ) {\n    const vsModule = this.device.createShaderModule({ code: vertexShader });\n    const fsModule = this.device.createShaderModule({\n      code: `\n        [[stage(fragment)]] fn main() -> [[location(0)]] vec4<f32> {\n          return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n        }`,\n    });\n\n    this.expectValidationError(() => {\n      this.device.createRenderPipeline({\n        vertex: {\n          module: vsModule,\n          entryPoint: 'main',\n          buffers,\n        },\n        fragment: {\n          module: fsModule,\n          entryPoint: 'main',\n          targets: [{ format: 'rgba8unorm' }],\n        },\n        primitive: { topology: 'triangle-list' },\n      });\n    }, !success);\n  }\n\n  generateTestVertexShader(inputs: { type: string; location: number }[]): string {\n    let interfaces = '';\n    let body = '';\n\n    let count = 0;\n    for (const input of inputs) {\n      interfaces += `[[location(${input.location})]] input${count} : ${input.type};\\n`;\n      body += `var i${count} : ${input.type} = input.input${count};\\n`;\n      count++;\n    }\n\n    return `\n      struct Inputs {\n        ${interfaces}\n      };\n      [[stage(vertex)]] fn main(input : Inputs) -> [[builtin(position)]] vec4<f32> {\n        ${body}\n        return vec4<f32>(0.0, 0.0, 0.0, 0.0);\n      }\n    `;\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('max_vertex_buffer_limit')\n  .desc(\n    `Test that only up to <maxVertexBuffers> vertex buffers are allowed.\n   - Tests with 0, 1, limits, limits + 1 vertex buffers.\n   - Tests with the last buffer having an attribute or not.\n  This also happens to test that vertex buffers with no attributes are allowed and that a vertex state with no buffers is allowed.`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('count', [0, 1, kMaxVertexBuffers, kMaxVertexBuffers + 1]))\n      .combine(pbool('lastEmpty'))\n  )\n  .fn(t => {\n    const { count, lastEmpty } = t.params;\n\n    const vertexBuffers = [];\n    for (let i = 0; i < count; i++) {\n      if (lastEmpty || i !== count - 1) {\n        vertexBuffers.push({ attributes: [], arrayStride: 0 });\n      } else {\n        vertexBuffers.push({\n          attributes: [{ format: 'float32', offset: 0, shaderLocation: 0 }],\n          arrayStride: 0,\n        } as const);\n      }\n    }\n\n    const success = count <= kMaxVertexBuffers;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('max_vertex_attribute_limit')\n  .desc(\n    `Test that only up to <maxVertexAttributes> vertex attributes are allowed.\n   - Tests with 0, 1, limit, limits + 1 vertex attribute.\n   - Tests with 0, 1, 4 attributes per buffer (with remaining attributes in the last buffer).`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('attribCount', [0, 1, kMaxVertexAttributes, kMaxVertexAttributes + 1]))\n      .combine(poptions('attribsPerBuffer', [0, 1, 4]))\n  )\n  .fn(t => {\n    const { attribCount, attribsPerBuffer } = t.params;\n\n    const vertexBuffers = [];\n\n    let attribsAdded = 0;\n    while (attribsAdded !== attribCount) {\n      // Choose how many attributes to add for this buffer. The last buffer gets all remaining attributes.\n      let targetCount = Math.min(attribCount, attribsAdded + attribsPerBuffer);\n      if (vertexBuffers.length === kMaxVertexBuffers - 1) {\n        targetCount = attribCount;\n      }\n\n      const attributes = [];\n      while (attribsAdded !== targetCount) {\n        attributes.push({ format: 'float32', offset: 0, shaderLocation: attribsAdded } as const);\n        attribsAdded++;\n      }\n\n      vertexBuffers.push({ arrayStride: 0, attributes });\n    }\n\n    const success = attribCount <= kMaxVertexAttributes;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('max_vertex_buffer_array_stride_limit')\n  .desc(\n    `Test that the vertex buffer arrayStride must be at most <maxVertexBufferArrayStride>.\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 4, 256, limit - 4, limit, limit + 4`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(\n        poptions('arrayStride', [\n          0,\n          4,\n          256,\n          kMaxVertexBufferArrayStride - 4,\n          kMaxVertexBufferArrayStride,\n          kMaxVertexBufferArrayStride + 4,\n        ])\n      )\n  )\n  .fn(t => {\n    const { vertexBufferIndex, arrayStride } = t.params;\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride <= kMaxVertexBufferArrayStride;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_buffer_array_stride_limit_alignment')\n  .desc(\n    `Test that the vertex buffer arrayStride must be a multiple of 4 (including 0).\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 1, 2, 4, limit - 4, limit - 2, limit`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(\n        poptions('arrayStride', [\n          0,\n          1,\n          2,\n          4,\n          kMaxVertexBufferArrayStride - 4,\n          kMaxVertexBufferArrayStride - 2,\n          kMaxVertexBufferArrayStride,\n        ])\n      )\n  )\n  .fn(t => {\n    const { vertexBufferIndex, arrayStride } = t.params;\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride % 4 === 0;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_attribute_shaderLocation_limit')\n  .desc(\n    `Test shaderLocation must be less than maxVertexAttributes.\n   - Test for various vertex buffer indices\n   - Test for various amounts of attributes in that vertex buffer\n   - Test for shaderLocation 0, 1, limit - 1, limit`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1]))\n      .combine(pbool('testAttributeAtStart'))\n      .combine(\n        poptions('testShaderLocation', [0, 1, kMaxVertexAttributes - 1, kMaxVertexAttributes])\n      )\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndex,\n      extraAttributeCount,\n      testShaderLocation,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttribute[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: testShaderLocation },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [testShaderLocation],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n\n    const success = testShaderLocation < kMaxVertexAttributes;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_attribute_shaderLocation_unique')\n  .desc(\n    `Test that shaderLocation must be unique in the vertex state.\n   - Test for various pairs of buffers that contain the potentially conflicting attributes\n   - Test for the potentially conflicting attributes in various places in the buffers (with dummy attributes)\n   - Test for various shaderLocations that conflict or not`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndexA', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('vertexBufferIndexB', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(pbool('testAttributeAtStartA'))\n      .combine(pbool('testAttributeAtStartB'))\n      .combine(poptions('shaderLocationA', [0, 1, 7, kMaxVertexAttributes - 1]))\n      .combine(poptions('shaderLocationB', [0, 1, 7, kMaxVertexAttributes - 1]))\n      .combine(poptions('extraAttributeCount', [0, 4]))\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndexA,\n      vertexBufferIndexB,\n      testAttributeAtStartA,\n      testAttributeAtStartB,\n      shaderLocationA,\n      shaderLocationB,\n      extraAttributeCount,\n    } = t.params;\n\n    // Depending on the params, the vertexBuffer for A and B can be the same or different. To support\n    // both cases without code changes we treat `vertexBufferAttributes` as a map from indices to\n    // vertex buffer descriptors, with A and B potentially reusing the same JS object if they have the\n    // same index.\n    const vertexBufferAttributes = [];\n    vertexBufferAttributes[vertexBufferIndexA] = [];\n    vertexBufferAttributes[vertexBufferIndexB] = [];\n\n    // Add the dummy attributes for attribute A\n    const attributesA = vertexBufferAttributes[vertexBufferIndexA];\n    addTestAttributes(attributesA, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: shaderLocationA },\n      testAttributeAtStart: testAttributeAtStartA,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [shaderLocationA, shaderLocationB],\n    });\n\n    // Add attribute B. Not that attributesB can be the same object as attributesA so they end\n    // up in the same vertex buffer.\n    const attributesB = vertexBufferAttributes[vertexBufferIndexB];\n    addTestAttributes(attributesB, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: shaderLocationB },\n      testAttributeAtStart: testAttributeAtStartB,\n    });\n\n    // Use the attributes to make the list of vertex buffers. Note that we might be setting the same vertex\n    // buffer twice, but that only happens when it is the only vertex buffer.\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndexA] = { arrayStride: 256, attributes: attributesA };\n    vertexBuffers[vertexBufferIndexB] = { arrayStride: 256, attributes: attributesB };\n\n    // Note that an empty vertex shader will be used so errors only happens because of the conflict\n    // in the vertex state.\n    const success = shaderLocationA !== shaderLocationB;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_shader_input_location_limit')\n  .desc(\n    `Test that vertex shader's input's location decoration must be less than maxVertexAttributes.\n   - Test for shaderLocation 0, 1, limit - 1, limit`\n  )\n  .subcases(() =>\n    params().combine(\n      poptions('testLocation', [0, 1, kMaxVertexAttributes - 1, kMaxVertexAttributes, -1, 2 ** 32])\n    )\n  )\n  .fn(t => {\n    const { testLocation } = t.params;\n\n    const shader = t.generateTestVertexShader([\n      {\n        type: 'vec4<f32>',\n        location: testLocation,\n      },\n    ]);\n\n    const vertexBuffers = [\n      {\n        arrayStride: 512,\n        attributes: [\n          {\n            format: 'float32',\n            offset: 0,\n            shaderLocation: testLocation,\n          } as const,\n        ],\n      },\n    ];\n\n    const success = testLocation < kMaxVertexAttributes;\n    t.testVertexState(success, vertexBuffers, shader);\n  });\n\ng.test('vertex_shader_input_location_in_vertex_state')\n  .desc(\n    `Test that a vertex shader defined in the shader must have a corresponding attribute in the vertex state.\n       - Test for various input locations.\n       - Test for the attribute in various places in the list of vertex buffer and various places inside the vertex buffer descriptor`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1]))\n      .combine(pbool('testAttributeAtStart'))\n      .combine(poptions('testShaderLocation', [0, 1, 4, 7, kMaxVertexAttributes - 1]))\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndex,\n      extraAttributeCount,\n      testAttributeAtStart,\n      testShaderLocation,\n    } = t.params;\n    // We have a shader using `testShaderLocation`.\n    const shader = t.generateTestVertexShader([\n      {\n        type: 'vec4<f32>',\n        location: testShaderLocation,\n      },\n    ]);\n\n    const attributes: GPUVertexAttribute[] = [];\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n\n    // Fill attributes with a bunch of attributes for other locations.\n    // Using that vertex state is invalid because the vertex state doesn't contain the test location\n    addTestAttributes(attributes, {\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [testShaderLocation],\n    });\n    t.testVertexState(false, vertexBuffers, shader);\n\n    // Add an attribute for the test location and try again.\n    addTestAttributes(attributes, {\n      testAttribute: { format: 'float32', shaderLocation: testShaderLocation, offset: 0 },\n      testAttributeAtStart,\n    });\n    t.testVertexState(true, vertexBuffers, shader);\n  });\n\ng.test('vertex_shader_type_matches_attribute_format')\n  .desc(\n    `\n    Test that the vertex shader declaration must have a type compatible with the vertex format.\n     - Test for all formats.\n     - Test for all combinations of u/i/f32 with and without vectors.`\n  )\n  .cases(poptions('format', kVertexFormats))\n  .subcases(() =>\n    params()\n      .combine(poptions('shaderBaseType', ['u32', 'i32', 'f32']))\n      .expand(p => {\n        return poptions('shaderType', [\n          p.shaderBaseType,\n          `vec2<${p.shaderBaseType}>`,\n          `vec3<${p.shaderBaseType}>`,\n          `vec4<${p.shaderBaseType}>`,\n        ]);\n      })\n  )\n  .fn(t => {\n    const { format, shaderBaseType, shaderType } = t.params;\n    const shader = t.generateTestVertexShader([\n      {\n        type: shaderType,\n        location: 0,\n      },\n    ]);\n\n    const requiredBaseType = {\n      sint: 'i32',\n      uint: 'u32',\n      snorm: 'f32',\n      unorm: 'f32',\n      float: 'f32',\n    }[kVertexFormatInfo[format].type];\n\n    const success = requiredBaseType === shaderBaseType;\n    t.testVertexState(\n      success,\n      [\n        {\n          arrayStride: 0,\n          attributes: [{ offset: 0, shaderLocation: 0, format }],\n        },\n      ],\n      shader\n    );\n  });\n\ng.test('vertex_attribute_offset_alignment')\n  .desc(\n    `\n    Test that vertex attribute offsets must be aligned to the format's component byte size.\n    - Test for all formats.\n    - Test for various arrayStrides and offsets within that stride\n    - Test for various vertex buffer indices\n    - Test for various amounts of attributes in that vertex buffer`\n  )\n  .cases(\n    params()\n      .combine(poptions('format', kVertexFormats))\n      .combine(poptions('arrayStride', [256, kMaxVertexBufferArrayStride]))\n      .expand(p => {\n        const { bytesPerComponent, componentCount } = kVertexFormatInfo[p.format];\n        const formatSize = bytesPerComponent * componentCount;\n        const halfAlignment = Math.floor(bytesPerComponent / 2);\n\n        return poptions(\n          'offset',\n          new Set([\n            0,\n            halfAlignment,\n            bytesPerComponent,\n            p.arrayStride - formatSize,\n            p.arrayStride - formatSize - halfAlignment,\n          ])\n        );\n      })\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1]))\n      .combine(pbool('testAttributeAtStart'))\n  )\n  .fn(t => {\n    const {\n      format,\n      arrayStride,\n      offset,\n      vertexBufferIndex,\n      extraAttributeCount,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttribute[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format, offset, shaderLocation: 0 },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [0],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes };\n\n    const success = offset % kVertexFormatInfo[format].bytesPerComponent === 0;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('vertex_attribute_contained_in_stride')\n  .desc(\n    `\n    Test that vertex attribute [offset, offset + formatSize) must be contained in the arrayStride if arrayStride is not 0:\n    - Test for all formats.\n    - Test for various arrayStrides and offsets within that stride\n    - Test for various vertex buffer indices\n    - Test for various amounts of attributes in that vertex buffer`\n  )\n  .cases(poptions('format', kVertexFormats))\n  .subcases(({ format }) =>\n    params()\n      .combine(\n        poptions('arrayStride', [\n          0,\n          256,\n          kMaxVertexBufferArrayStride - 4,\n          kMaxVertexBufferArrayStride,\n        ])\n      )\n      .expand(p => {\n        // Compute a bunch of test offsets to test.\n        const { bytesPerComponent, componentCount } = kVertexFormatInfo[format];\n        const formatSize = bytesPerComponent * componentCount;\n        const offsetsToTest = [0, bytesPerComponent];\n\n        // arrayStride = 0 is a special case because for the offset validation it acts the same\n        // as arrayStride = kMaxVertexBufferArrayStride. We branch so as to avoid adding negative\n        // offsets that would cause an IDL exception to be thrown instead of a validation error.\n        if (p.arrayStride === 0) {\n          offsetsToTest.push(kMaxVertexBufferArrayStride - formatSize);\n          offsetsToTest.push(kMaxVertexBufferArrayStride - formatSize + bytesPerComponent);\n        } else {\n          offsetsToTest.push(p.arrayStride - formatSize);\n          offsetsToTest.push(p.arrayStride - formatSize + bytesPerComponent);\n        }\n\n        return poptions('offset', offsetsToTest);\n      })\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1]))\n      .combine(pbool('testAttributeAtStart'))\n  )\n  .fn(t => {\n    const {\n      format,\n      arrayStride,\n      offset,\n      vertexBufferIndex,\n      extraAttributeCount,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttribute[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format, offset, shaderLocation: 0 },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [0],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes };\n\n    const formatInfo = kVertexFormatInfo[format];\n    const formatSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n    const limit = arrayStride === 0 ? kMaxVertexBufferArrayStride : arrayStride;\n\n    const success = offset + formatSize <= limit;\n    t.testVertexState(success, vertexBuffers);\n  });\n\ng.test('many_attributes_overlapping')\n  .desc(`Test that it is valid to have many vertex attributes overlap`)\n  .fn(async t => {\n    // Create many attributes, each of them intersects with at least 3 others.\n    const attributes = [];\n    const formats = ['float32x4', 'uint32x4', 'sint32x4'] as const;\n    for (let i = 0; i < kMaxVertexAttributes; i++) {\n      attributes.push({ format: formats[i % 3], offset: i * 4, shaderLocation: i } as const);\n    }\n\n    t.testVertexState(true, [{ arrayStride: 0, attributes }]);\n  });\n"],"file":"vertex_state.spec.js"}