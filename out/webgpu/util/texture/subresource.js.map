{"version":3,"sources":["../../../../src/webgpu/util/texture/subresource.ts"],"names":["assert","kAllTextureFormatInfo","align","standardizeExtent3D","endOfRange","r","begin","count","end","rangeAsIterator","i","SubresourceRange","constructor","subresources","mipRange","sliceRange","each","level","slice","mipLevels","slices","mipSize","size","rShiftMax1","s","Math","max","Array","map","size_","width","height","depthOrArrayLayers","physicalMipSize","format","dimension","virtualWidthAtLevel","virtualHeightAtLevel","physicalWidthAtLevel","blockWidth","physicalHeightAtLevel","blockHeight"],"mappings":"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","sourcesContent":["import { assert } from '../../../common/framework/util/util.js';\nimport { kAllTextureFormatInfo } from '../../capability_info.js';\nimport { align } from '../../util/math.js';\nimport { standardizeExtent3D } from '../unions.js';\n\nexport interface BeginCountRange {\n  begin: number;\n  count: number;\n}\n\nexport interface BeginEndRange {\n  begin: number;\n  end: number;\n}\n\nfunction endOfRange(r: BeginEndRange | BeginCountRange): number {\n  return 'count' in r ? r.begin + r.count : r.end;\n}\n\nfunction* rangeAsIterator(r: BeginEndRange | BeginCountRange): Generator<number> {\n  for (let i = r.begin; i < endOfRange(r); ++i) {\n    yield i;\n  }\n}\n\nexport class SubresourceRange {\n  readonly mipRange: BeginEndRange;\n  readonly sliceRange: BeginEndRange;\n\n  constructor(subresources: {\n    mipRange: BeginEndRange | BeginCountRange;\n    sliceRange: BeginEndRange | BeginCountRange;\n  }) {\n    this.mipRange = {\n      begin: subresources.mipRange.begin,\n      end: endOfRange(subresources.mipRange),\n    };\n    this.sliceRange = {\n      begin: subresources.sliceRange.begin,\n      end: endOfRange(subresources.sliceRange),\n    };\n  }\n\n  *each(): Generator<{ level: number; slice: number }> {\n    for (let level = this.mipRange.begin; level < this.mipRange.end; ++level) {\n      for (let slice = this.sliceRange.begin; slice < this.sliceRange.end; ++slice) {\n        yield { level, slice };\n      }\n    }\n  }\n\n  *mipLevels(): Generator<{ level: number; slices: Generator<number> }> {\n    for (let level = this.mipRange.begin; level < this.mipRange.end; ++level) {\n      yield {\n        level,\n        slices: rangeAsIterator(this.sliceRange),\n      };\n    }\n  }\n}\n\nexport function mipSize(size: readonly [number], level: number): [number];\nexport function mipSize(size: readonly [number, number], level: number): [number, number];\nexport function mipSize(\n  size: readonly [number, number, number],\n  level: number\n): [number, number, number];\nexport function mipSize(size: GPUExtent3DDict, level: number): GPUExtent3DDict;\nexport function mipSize(size: Readonly<GPUExtent3D>, level: number): GPUExtent3D {\n  const rShiftMax1 = (s: number) => Math.max(s >> level, 1);\n  if (size instanceof Array) {\n    return size.map(rShiftMax1);\n  } else {\n    const size_ = standardizeExtent3D(size);\n    return {\n      width: rShiftMax1(size_.width),\n      height: rShiftMax1(size_.height),\n      depthOrArrayLayers: rShiftMax1(size_.depthOrArrayLayers),\n    };\n  }\n}\n\n// TODO(jiawei.shao@intel.com): support 1D and 3D textures\nexport function physicalMipSize(\n  size: Required<GPUExtent3DDict>,\n  format: GPUTextureFormat,\n  dimension: GPUTextureDimension,\n  level: number\n): Required<GPUExtent3DDict> {\n  assert(dimension === '2d');\n  assert(Math.max(size.width, size.height) >> level > 0);\n\n  const virtualWidthAtLevel = Math.max(size.width >> level, 1);\n  const virtualHeightAtLevel = Math.max(size.height >> level, 1);\n  const physicalWidthAtLevel = align(virtualWidthAtLevel, kAllTextureFormatInfo[format].blockWidth);\n  const physicalHeightAtLevel = align(\n    virtualHeightAtLevel,\n    kAllTextureFormatInfo[format].blockHeight\n  );\n  return {\n    width: physicalWidthAtLevel,\n    height: physicalHeightAtLevel,\n    depthOrArrayLayers: size.depthOrArrayLayers,\n  };\n}\n"],"file":"subresource.js"}