{"version":3,"sources":["../../../../src/webgpu/util/texture/image_copy.ts"],"names":["assert","kSizedTextureFormatInfo","align","standardizeExtent3D","kImageCopyTypes","bytesInACompleteRow","copyWidth","format","info","blockWidth","bytesPerBlock","validateBytesPerRow","bytesPerRow","bytesInLastRow","sizeInBlocks","undefined","height","depthOrArrayLayers","validateRowsPerImage","rowsPerImage","dataBytesForCopyOrFail","args","minDataSizeOrOverestimate","copyValid","dataBytesForCopyOrOverestimate","layout","copySize","copySize_","method","copyExtent","width","blockHeight","valid","offset","requiredBytesInCopy","bytesPerImage","bytesBeforeLastImage"],"mappings":"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","sourcesContent":["import { assert } from '../../../common/framework/util/util.js';\nimport { kSizedTextureFormatInfo, SizedTextureFormat } from '../../capability_info.js';\nimport { align } from '../math.js';\nimport { standardizeExtent3D } from '../unions.js';\n\nexport type ImageCopyType = 'WriteTexture' | 'CopyB2T' | 'CopyT2B';\nexport const kImageCopyTypes: readonly ImageCopyType[] = [\n  'WriteTexture',\n  'CopyB2T',\n  'CopyT2B',\n] as const;\n\nexport function bytesInACompleteRow(copyWidth: number, format: SizedTextureFormat): number {\n  const info = kSizedTextureFormatInfo[format];\n  assert(copyWidth % info.blockWidth === 0);\n  return (info.bytesPerBlock * copyWidth) / info.blockWidth;\n}\n\nfunction validateBytesPerRow({\n  bytesPerRow,\n  bytesInLastRow,\n  sizeInBlocks,\n}: {\n  bytesPerRow: number | undefined;\n  bytesInLastRow: number;\n  sizeInBlocks: Required<GPUExtent3DDict>;\n}) {\n  // If specified, layout.bytesPerRow must be greater than or equal to bytesInLastRow.\n  if (bytesPerRow !== undefined && bytesPerRow < bytesInLastRow) {\n    return false;\n  }\n  // If heightInBlocks > 1, layout.bytesPerRow must be specified.\n  // If copyExtent.depthOrArrayLayers > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n  if (\n    bytesPerRow === undefined &&\n    (sizeInBlocks.height > 1 || sizeInBlocks.depthOrArrayLayers > 1)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction validateRowsPerImage({\n  rowsPerImage,\n  sizeInBlocks,\n}: {\n  rowsPerImage: number | undefined;\n  sizeInBlocks: Required<GPUExtent3DDict>;\n}) {\n  // If specified, layout.rowsPerImage must be greater than or equal to heightInBlocks.\n  if (rowsPerImage !== undefined && rowsPerImage < sizeInBlocks.height) {\n    return false;\n  }\n  // If copyExtent.depthOrArrayLayers > 1, layout.bytesPerRow and layout.rowsPerImage must be specified.\n  if (rowsPerImage === undefined && sizeInBlocks.depthOrArrayLayers > 1) {\n    return false;\n  }\n  return true;\n}\n\ninterface DataBytesForCopyArgs {\n  layout: GPUImageDataLayout;\n  format: SizedTextureFormat;\n  copySize: GPUExtent3D;\n  method: ImageCopyType;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. Throws if the copy is invalid.\n */\nexport function dataBytesForCopyOrFail(args: DataBytesForCopyArgs): number {\n  const { minDataSizeOrOverestimate, copyValid } = dataBytesForCopyOrOverestimate(args);\n  assert(copyValid, 'copy was invalid');\n  return minDataSizeOrOverestimate;\n}\n\n/**\n * Validate a copy and compute the number of bytes it needs. If the copy is invalid, attempts to\n * \"conservatively guess\" (overestimate) the number of bytes that could be needed for a copy, even\n * if the copy parameters turn out to be invalid. This hopes to avoid \"buffer too small\" validation\n * errors when attempting to test other validation errors.\n */\nexport function dataBytesForCopyOrOverestimate({\n  layout,\n  format,\n  copySize: copySize_,\n  method,\n}: DataBytesForCopyArgs): { minDataSizeOrOverestimate: number; copyValid: boolean } {\n  const copyExtent = standardizeExtent3D(copySize_);\n\n  const info = kSizedTextureFormatInfo[format];\n  assert(copyExtent.width % info.blockWidth === 0);\n  assert(copyExtent.height % info.blockHeight === 0);\n  const sizeInBlocks = {\n    width: copyExtent.width / info.blockWidth,\n    height: copyExtent.height / info.blockHeight,\n    depthOrArrayLayers: copyExtent.depthOrArrayLayers,\n  } as const;\n  const bytesInLastRow = sizeInBlocks.width * info.bytesPerBlock;\n\n  let valid = true;\n  const offset = layout.offset ?? 0;\n  if (method !== 'WriteTexture') {\n    if (offset % info.bytesPerBlock !== 0) valid = false;\n    if (layout.bytesPerRow && layout.bytesPerRow % 256 !== 0) valid = false;\n  }\n\n  let requiredBytesInCopy = 0;\n  {\n    let { bytesPerRow, rowsPerImage } = layout;\n\n    // If bytesPerRow or rowsPerImage is invalid, guess a value for the sake of various tests that\n    // don't actually care about the exact value.\n    // (In particular for validation tests that want to test invalid bytesPerRow or rowsPerImage but\n    // need to make sure the total buffer size is still big enough.)\n    if (!validateBytesPerRow({ bytesPerRow, bytesInLastRow, sizeInBlocks })) {\n      bytesPerRow = undefined;\n      valid = false;\n    }\n    if (!validateRowsPerImage({ rowsPerImage, sizeInBlocks })) {\n      rowsPerImage = undefined;\n      valid = false;\n    }\n    // Pick values for cases when (a) bpr/rpi was invalid or (b) they're validly undefined.\n    bytesPerRow ??= align(info.bytesPerBlock * sizeInBlocks.width, 256);\n    rowsPerImage ??= sizeInBlocks.height;\n\n    if (copyExtent.depthOrArrayLayers > 1) {\n      const bytesPerImage = bytesPerRow * rowsPerImage;\n      const bytesBeforeLastImage = bytesPerImage * (copyExtent.depthOrArrayLayers - 1);\n      requiredBytesInCopy += bytesBeforeLastImage;\n    }\n    if (copyExtent.depthOrArrayLayers > 0) {\n      if (sizeInBlocks.height > 1) requiredBytesInCopy += bytesPerRow * (sizeInBlocks.height - 1);\n      if (sizeInBlocks.height > 0) requiredBytesInCopy += bytesInLastRow;\n    }\n  }\n\n  return { minDataSizeOrOverestimate: offset + requiredBytesInCopy, copyValid: valid };\n}\n"],"file":"image_copy.js"}