{"version":3,"sources":["../../src/webgpu/gpu_test.ts"],"names":["Fixture","attemptGarbageCollection","assert","DevicePool","TestOOMedShouldAttemptGC","align","fillTextureDataWithTexelValue","getTextureCopyLayout","getTexelDataRepresentation","devicePool","GPUTest","device","provider","undefined","acquiredDevice","acquire","queue","defaultQueue","init","reserve","selectDeviceOrSkipTestCase","descriptor","oldProvider","release","finalize","threw","ex","createCopyForMapRead","src","srcOffset","size","dst","createBuffer","usage","GPUBufferUsage","MAP_READ","COPY_DST","c","createCommandEncoder","copyBufferToBuffer","submit","finish","createAlignedCopyForMapRead","offset","alignedOffset","Math","floor","offsetDifference","alignedSize","begin","end","expectContents","expected","byteLength","eventualAsyncExpectation","niceStack","constructor","mapAsync","GPUMapMode","READ","actual","getMappedRange","check","checkBuffer","subarray","message","rec","expectationFailed","destroy","expectBuffer","exp","Error","tolerance","failedByteIndices","failedByteExpectedValues","failedByteActualValues","i","tol","abs","length","push","toString","summary","join","lines","expHex","Array","from","Uint8Array","buffer","byteOffset","map","x","padStart","actHex","expectSingleColor","format","dimension","slice","layout","bytesPerRow","rowsPerImage","mipSize","expectedTexelData","getBytes","COPY_SRC","commandEncoder","copyTextureToBuffer","texture","mipLevel","origin","y","z","arrayBuffer","ArrayBuffer","expectGPUError","filter","fn","shouldError","pushErrorScope","returnValue","promise","popErrorScope","error","failed","GPUOutOfMemoryError","GPUValidationError","debug"],"mappings":"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","sourcesContent":["import { Fixture } from '../common/framework/fixture.js';\nimport { attemptGarbageCollection } from '../common/framework/util/collect_garbage.js';\nimport { assert } from '../common/framework/util/util.js';\n\nimport { EncodableTextureFormat } from './capability_info.js';\nimport { DevicePool, DeviceProvider, TestOOMedShouldAttemptGC } from './util/device_pool.js';\nimport { align } from './util/math.js';\nimport {\n  fillTextureDataWithTexelValue,\n  getTextureCopyLayout,\n  LayoutOptions as TextureLayoutOptions,\n} from './util/texture/layout.js';\nimport { PerTexelComponent, getTexelDataRepresentation } from './util/texture/texelData.js';\n\ntype TypedArrayBufferView =\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | Float32Array\n  | Float64Array;\n\ntype TypedArrayBufferViewConstructor =\n  | Uint8ArrayConstructor\n  | Uint16ArrayConstructor\n  | Uint32ArrayConstructor\n  | Int8ArrayConstructor\n  | Int16ArrayConstructor\n  | Int32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor;\n\nconst devicePool = new DevicePool();\n\nexport class GPUTest extends Fixture {\n  private provider: DeviceProvider | undefined;\n  /** Must not be replaced once acquired. */\n  private acquiredDevice: GPUDevice | undefined;\n\n  get device(): GPUDevice {\n    assert(\n      this.provider !== undefined,\n      'No provider available right now; did you \"await\" selectDeviceOrSkipTestCase?'\n    );\n    if (!this.acquiredDevice) {\n      this.acquiredDevice = this.provider.acquire();\n    }\n    return this.acquiredDevice;\n  }\n\n  get queue(): GPUQueue {\n    return this.device.defaultQueue;\n  }\n\n  async init(): Promise<void> {\n    await super.init();\n\n    this.provider = await devicePool.reserve();\n  }\n\n  /**\n   * When a GPUTest test accesses `.device` for the first time, a \"default\" GPUDevice\n   * (descriptor = `undefined`) is provided by default.\n   * However, some tests or cases need particular extensions to be enabled. Call this function with\n   * a descriptor (or undefined) to select a GPUDevice matching that descriptor.\n   *\n   * If the request descriptor can't be supported, throws an exception to skip the entire test case.\n   */\n  async selectDeviceOrSkipTestCase(descriptor: GPUDeviceDescriptor | undefined): Promise<void> {\n    assert(this.provider !== undefined);\n    // Make sure the device isn't replaced after it's been retrieved once.\n    assert(\n      !this.acquiredDevice,\n      \"Can't selectDeviceOrSkipTestCase() after the device has been used\"\n    );\n\n    const oldProvider = this.provider;\n    this.provider = undefined;\n    await devicePool.release(oldProvider);\n\n    this.provider = await devicePool.reserve(descriptor);\n    this.acquiredDevice = this.provider.acquire();\n  }\n\n  // Note: finalize is called even if init was unsuccessful.\n  async finalize(): Promise<void> {\n    await super.finalize();\n\n    if (this.provider) {\n      let threw: undefined | Error;\n      {\n        const provider = this.provider;\n        this.provider = undefined;\n        try {\n          await devicePool.release(provider);\n        } catch (ex) {\n          threw = ex;\n        }\n      }\n      // The GPUDevice and GPUQueue should now have no outstanding references.\n\n      if (threw) {\n        if (threw instanceof TestOOMedShouldAttemptGC) {\n          // Try to clean up, in case there are stray GPU resources in need of collection.\n          await attemptGarbageCollection();\n        }\n        throw threw;\n      }\n    }\n  }\n\n  createCopyForMapRead(src: GPUBuffer, srcOffset: number, size: number): GPUBuffer {\n    assert(srcOffset % 4 === 0);\n    assert(size % 4 === 0);\n\n    const dst = this.device.createBuffer({\n      size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n\n    const c = this.device.createCommandEncoder();\n    c.copyBufferToBuffer(src, srcOffset, dst, 0, size);\n\n    this.queue.submit([c.finish()]);\n\n    return dst;\n  }\n\n  // TODO: add an expectContents for textures, which logs data: uris on failure\n\n  // Offset and size passed to createCopyForMapRead must be divisible by 4. For that\n  // we might need to copy more bytes from the buffer than we want to map.\n  // begin and end values represent the part of the copied buffer that stores the contents\n  // we initially wanted to map.\n  // The copy will not cause an OOB error because the buffer size must be 4-aligned.\n  createAlignedCopyForMapRead(\n    src: GPUBuffer,\n    size: number,\n    offset: number\n  ): { dst: GPUBuffer; begin: number; end: number } {\n    const alignedOffset = Math.floor(offset / 4) * 4;\n    const offsetDifference = offset - alignedOffset;\n    const alignedSize = align(size + offsetDifference, 4);\n    const dst = this.createCopyForMapRead(src, alignedOffset, alignedSize);\n    return { dst, begin: offsetDifference, end: offsetDifference + size };\n  }\n\n  expectContents(src: GPUBuffer, expected: TypedArrayBufferView, srcOffset: number = 0): void {\n    const { dst, begin, end } = this.createAlignedCopyForMapRead(\n      src,\n      expected.byteLength,\n      srcOffset\n    );\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const constructor = expected.constructor as TypedArrayBufferViewConstructor;\n      await dst.mapAsync(GPUMapMode.READ);\n      const actual = new constructor(dst.getMappedRange());\n      const check = this.checkBuffer(actual.subarray(begin, end), expected);\n      if (check !== undefined) {\n        niceStack.message = check;\n        this.rec.expectationFailed(niceStack);\n      }\n      dst.destroy();\n    });\n  }\n\n  expectBuffer(actual: Uint8Array, exp: Uint8Array): void {\n    const check = this.checkBuffer(actual, exp);\n    if (check !== undefined) {\n      this.rec.expectationFailed(new Error(check));\n    }\n  }\n\n  checkBuffer(\n    actual: TypedArrayBufferView,\n    exp: TypedArrayBufferView,\n    tolerance: number | ((i: number) => number) = 0\n  ): string | undefined {\n    assert(actual.constructor === exp.constructor);\n\n    const size = exp.byteLength;\n    if (actual.byteLength !== size) {\n      return 'size mismatch';\n    }\n    const failedByteIndices: string[] = [];\n    const failedByteExpectedValues: string[] = [];\n    const failedByteActualValues: string[] = [];\n    for (let i = 0; i < size; ++i) {\n      const tol = typeof tolerance === 'function' ? tolerance(i) : tolerance;\n      if (Math.abs(actual[i] - exp[i]) > tol) {\n        if (failedByteIndices.length >= 4) {\n          failedByteIndices.push('...');\n          failedByteExpectedValues.push('...');\n          failedByteActualValues.push('...');\n          break;\n        }\n        failedByteIndices.push(i.toString());\n        failedByteExpectedValues.push(exp[i].toString());\n        failedByteActualValues.push(actual[i].toString());\n      }\n    }\n    const summary = `at [${failedByteIndices.join(', ')}], \\\nexpected [${failedByteExpectedValues.join(', ')}], \\\ngot [${failedByteActualValues.join(', ')}]`;\n    const lines = [summary];\n\n    // TODO: Could make a more convenient message, which could look like e.g.:\n    //\n    //   Starting at offset 48,\n    //              got 22222222 ABCDABCD 99999999\n    //     but expected 22222222 55555555 99999999\n    //\n    // or\n    //\n    //   Starting at offset 0,\n    //              got 00000000 00000000 00000000 00000000 (... more)\n    //     but expected 00FF00FF 00FF00FF 00FF00FF 00FF00FF (... more)\n    //\n    // Or, maybe these diffs aren't actually very useful (given we have the prints just above here),\n    // and we should remove them. More important will be logging of texture data in a visual format.\n\n    if (size <= 256 && failedByteIndices.length > 0) {\n      const expHex = Array.from(new Uint8Array(exp.buffer, exp.byteOffset, exp.byteLength))\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join('');\n      const actHex = Array.from(new Uint8Array(actual.buffer, actual.byteOffset, actual.byteLength))\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join('');\n      lines.push('EXPECT:\\t  ' + exp.join(' '));\n      lines.push('\\t0x' + expHex);\n      lines.push('ACTUAL:\\t  ' + actual.join(' '));\n      lines.push('\\t0x' + actHex);\n    }\n    if (failedByteIndices.length) {\n      return lines.join('\\n');\n    }\n    return undefined;\n  }\n\n  expectSingleColor(\n    src: GPUTexture,\n    format: EncodableTextureFormat,\n    {\n      size,\n      exp,\n      dimension = '2d',\n      slice = 0,\n      layout,\n    }: {\n      size: [number, number, number];\n      exp: PerTexelComponent<number>;\n      dimension?: GPUTextureDimension;\n      slice?: number;\n      layout?: TextureLayoutOptions;\n    }\n  ): void {\n    const { byteLength, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n      format,\n      dimension,\n      size,\n      layout\n    );\n    const expectedTexelData = getTexelDataRepresentation(format).getBytes(exp);\n\n    const buffer = this.device.createBuffer({\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyTextureToBuffer(\n      { texture: src, mipLevel: layout?.mipLevel, origin: { x: 0, y: 0, z: slice } },\n      { buffer, bytesPerRow, rowsPerImage },\n      mipSize\n    );\n    this.queue.submit([commandEncoder.finish()]);\n    const arrayBuffer = new ArrayBuffer(byteLength);\n    fillTextureDataWithTexelValue(expectedTexelData, format, dimension, arrayBuffer, size, layout);\n    this.expectContents(buffer, new Uint8Array(arrayBuffer));\n  }\n\n  expectGPUError<R>(filter: GPUErrorFilter, fn: () => R, shouldError: boolean = true): R {\n    // If no error is expected, we let the scope surrounding the test catch it.\n    if (!shouldError) {\n      return fn();\n    }\n\n    this.device.pushErrorScope(filter);\n    const returnValue = fn();\n    const promise = this.device.popErrorScope();\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const error = await promise;\n\n      let failed = false;\n      switch (filter) {\n        case 'out-of-memory':\n          failed = !(error instanceof GPUOutOfMemoryError);\n          break;\n        case 'validation':\n          failed = !(error instanceof GPUValidationError);\n          break;\n      }\n\n      if (failed) {\n        niceStack.message = `Expected ${filter} error`;\n        this.rec.expectationFailed(niceStack);\n      } else {\n        niceStack.message = `Captured ${filter} error`;\n        if (error instanceof GPUValidationError) {\n          niceStack.message += ` - ${error.message}`;\n        }\n        this.rec.debug(niceStack);\n      }\n    });\n\n    return returnValue;\n  }\n}\n"],"file":"gpu_test.js"}