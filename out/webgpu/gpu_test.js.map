{"version":3,"sources":["../../src/webgpu/gpu_test.ts"],"names":["Fixture","attemptGarbageCollection","assert","kAllTextureFormatInfo","kQueryTypeInfo","makeBufferWithContents","DevicePool","TestOOMedShouldAttemptGC","align","fillTextureDataWithTexelValue","getTextureCopyLayout","kTexelRepresentationInfo","devicePool","GPUTest","device","provider","undefined","acquiredDevice","acquire","queue","init","reserve","selectDeviceOrSkipTestCase","descriptor","nonGuaranteedFeatures","Array","filter","f","oldProvider","release","selectDeviceForTextureFormatOrSkipTestCase","formats","isArray","features","Set","format","add","feature","from","selectDeviceForQueryTypeOrSkipTestCase","types","map","t","finalize","threw","ex","createCopyForMapRead","src","srcOffset","size","dst","createBuffer","usage","GPUBufferUsage","MAP_READ","COPY_DST","c","createCommandEncoder","copyBufferToBuffer","submit","finish","createAlignedCopyForMapRead","offset","alignedOffset","Math","floor","offsetDifference","alignedSize","begin","end","expectContents","expected","generateWarningOnly","byteLength","eventualAsyncExpectation","niceStack","constructor","mapAsync","GPUMapMode","READ","actual","getMappedRange","check","checkBuffer","subarray","message","rec","warn","expectationFailed","destroy","expectContentsBetweenTwoValues","length","bounds","i","len","min","max","checkBufferFn","lines","x","toString","padStart","exp0Hex","Uint8Array","buffer","byteOffset","join","push","exp1Hex","expectContentsTwoValidValues","expected1","expected2","check1","check2","expectBuffer","exp","Error","tolerance","failedByteIndices","failedByteExpectedValues","failedByteActualValues","tol","abs","summary","expHex","actHex","checkFn","errorMsgFn","result","expectSingleColor","dimension","slice","layout","bytesPerRow","rowsPerImage","mipSize","rep","expectedTexelData","pack","encode","COPY_SRC","commandEncoder","copyTextureToBuffer","texture","mipLevel","origin","y","z","arrayBuffer","ArrayBuffer","readSinglePixelFrom2DTexture","expectSinglePixelIn2DTexture","expectSinglePixelBetweenTwoValuesIn2DTexture","expectGPUError","fn","shouldError","pushErrorScope","returnValue","promise","popErrorScope","error","failed","GPUOutOfMemoryError","GPUValidationError","debug","dataArray","createTexture2DWithMipmaps","mipmapDataArray","mipLevelCount","textureSizeMipmap0","createTexture","width","height","depthOrArrayLayers","GPUTextureUsage","SAMPLED","textureEncoder","data","mipLevelData","r","o","copyBufferToTexture"],"mappings":"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","sourcesContent":["import { Fixture } from '../common/framework/fixture.js';\nimport { attemptGarbageCollection } from '../common/framework/util/collect_garbage.js';\nimport { assert } from '../common/framework/util/util.js';\n\nimport {\n  EncodableTextureFormat,\n  SizedTextureFormat,\n  kAllTextureFormatInfo,\n  kQueryTypeInfo,\n} from './capability_info.js';\nimport { makeBufferWithContents } from './util/buffer.js';\nimport {\n  DevicePool,\n  DeviceProvider,\n  TestOOMedShouldAttemptGC,\n  UncanonicalizedDeviceDescriptor,\n} from './util/device_pool.js';\nimport { align } from './util/math.js';\nimport {\n  fillTextureDataWithTexelValue,\n  getTextureCopyLayout,\n  LayoutOptions as TextureLayoutOptions,\n} from './util/texture/layout.js';\nimport { PerTexelComponent, kTexelRepresentationInfo } from './util/texture/texel_data.js';\n\nexport type TypedArrayBufferView =\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | Float32Array\n  | Float64Array;\n\nexport type TypedArrayBufferViewConstructor =\n  | Uint8ArrayConstructor\n  | Uint16ArrayConstructor\n  | Uint32ArrayConstructor\n  | Int8ArrayConstructor\n  | Int16ArrayConstructor\n  | Int32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor;\n\nconst devicePool = new DevicePool();\n\nexport class GPUTest extends Fixture {\n  private provider: DeviceProvider | undefined;\n  /** Must not be replaced once acquired. */\n  private acquiredDevice: GPUDevice | undefined;\n\n  get device(): GPUDevice {\n    assert(\n      this.provider !== undefined,\n      'No provider available right now; did you \"await\" selectDeviceOrSkipTestCase?'\n    );\n    if (!this.acquiredDevice) {\n      this.acquiredDevice = this.provider.acquire();\n    }\n    return this.acquiredDevice;\n  }\n\n  get queue(): GPUQueue {\n    return this.device.queue;\n  }\n\n  async init(): Promise<void> {\n    await super.init();\n\n    this.provider = await devicePool.reserve();\n  }\n\n  /**\n   * When a GPUTest test accesses `.device` for the first time, a \"default\" GPUDevice\n   * (descriptor = `undefined`) is provided by default.\n   * However, some tests or cases need particular nonGuaranteedFeatures to be enabled.\n   * Call this function with a descriptor or feature name (or `undefined`) to select a\n   * GPUDevice with matching capabilities.\n   *\n   * If the request descriptor can't be supported, throws an exception to skip the entire test case.\n   */\n  async selectDeviceOrSkipTestCase(\n    descriptor:\n      | UncanonicalizedDeviceDescriptor\n      | GPUFeatureName\n      | undefined\n      | Array<GPUFeatureName | undefined>\n  ): Promise<void> {\n    if (descriptor === undefined) return;\n    if (typeof descriptor === 'string') {\n      descriptor = { nonGuaranteedFeatures: [descriptor] };\n    } else if (descriptor instanceof Array) {\n      descriptor = {\n        nonGuaranteedFeatures: descriptor.filter(f => f !== undefined) as GPUFeatureName[],\n      };\n    }\n\n    assert(this.provider !== undefined);\n    // Make sure the device isn't replaced after it's been retrieved once.\n    assert(\n      !this.acquiredDevice,\n      \"Can't selectDeviceOrSkipTestCase() after the device has been used\"\n    );\n\n    const oldProvider = this.provider;\n    this.provider = undefined;\n    await devicePool.release(oldProvider);\n\n    this.provider = await devicePool.reserve(descriptor);\n    this.acquiredDevice = this.provider.acquire();\n  }\n\n  async selectDeviceForTextureFormatOrSkipTestCase(\n    formats: GPUTextureFormat | undefined | (GPUTextureFormat | undefined)[]\n  ): Promise<void> {\n    if (!Array.isArray(formats)) {\n      formats = [formats];\n    }\n    const features = new Set<GPUFeatureName | undefined>();\n    for (const format of formats) {\n      if (format !== undefined) {\n        features.add(kAllTextureFormatInfo[format].feature);\n      }\n    }\n\n    await this.selectDeviceOrSkipTestCase(Array.from(features));\n  }\n\n  async selectDeviceForQueryTypeOrSkipTestCase(\n    types: GPUQueryType | GPUQueryType[]\n  ): Promise<void> {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n    const features = types.map(t => kQueryTypeInfo[t].feature);\n    await this.selectDeviceOrSkipTestCase(features);\n  }\n\n  // Note: finalize is called even if init was unsuccessful.\n  async finalize(): Promise<void> {\n    await super.finalize();\n\n    if (this.provider) {\n      let threw: undefined | Error;\n      {\n        const provider = this.provider;\n        this.provider = undefined;\n        try {\n          await devicePool.release(provider);\n        } catch (ex) {\n          threw = ex;\n        }\n      }\n      // The GPUDevice and GPUQueue should now have no outstanding references.\n\n      if (threw) {\n        if (threw instanceof TestOOMedShouldAttemptGC) {\n          // Try to clean up, in case there are stray GPU resources in need of collection.\n          await attemptGarbageCollection();\n        }\n        throw threw;\n      }\n    }\n  }\n\n  createCopyForMapRead(src: GPUBuffer, srcOffset: number, size: number): GPUBuffer {\n    assert(srcOffset % 4 === 0);\n    assert(size % 4 === 0);\n\n    const dst = this.device.createBuffer({\n      size,\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n\n    const c = this.device.createCommandEncoder();\n    c.copyBufferToBuffer(src, srcOffset, dst, 0, size);\n\n    this.queue.submit([c.finish()]);\n\n    return dst;\n  }\n\n  // TODO: add an expectContents for textures, which logs data: uris on failure\n\n  // Offset and size passed to createCopyForMapRead must be divisible by 4. For that\n  // we might need to copy more bytes from the buffer than we want to map.\n  // begin and end values represent the part of the copied buffer that stores the contents\n  // we initially wanted to map.\n  // The copy will not cause an OOB error because the buffer size must be 4-aligned.\n  createAlignedCopyForMapRead(\n    src: GPUBuffer,\n    size: number,\n    offset: number\n  ): { dst: GPUBuffer; begin: number; end: number } {\n    const alignedOffset = Math.floor(offset / 4) * 4;\n    const offsetDifference = offset - alignedOffset;\n    const alignedSize = align(size + offsetDifference, 4);\n    const dst = this.createCopyForMapRead(src, alignedOffset, alignedSize);\n    return { dst, begin: offsetDifference, end: offsetDifference + size };\n  }\n\n  expectContents(\n    src: GPUBuffer,\n    expected: TypedArrayBufferView,\n    srcOffset: number = 0,\n    { generateWarningOnly = false }: { generateWarningOnly?: boolean } = {}\n  ): void {\n    const { dst, begin, end } = this.createAlignedCopyForMapRead(\n      src,\n      expected.byteLength,\n      srcOffset\n    );\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const constructor = expected.constructor as TypedArrayBufferViewConstructor;\n      await dst.mapAsync(GPUMapMode.READ);\n      const actual = new constructor(dst.getMappedRange());\n      const check = this.checkBuffer(actual.subarray(begin, end), expected);\n      if (check !== undefined) {\n        niceStack.message = check;\n        if (generateWarningOnly) {\n          this.rec.warn(niceStack);\n        } else {\n          this.rec.expectationFailed(niceStack);\n        }\n      }\n      dst.destroy();\n    });\n  }\n\n  expectContentsBetweenTwoValues(\n    src: GPUBuffer,\n    expected: [TypedArrayBufferView, TypedArrayBufferView],\n    srcOffset: number = 0,\n    { generateWarningOnly = false }: { generateWarningOnly?: boolean }\n  ): void {\n    assert(expected[0].constructor === expected[1].constructor);\n    assert(expected[0].length === expected[1].length);\n    const { dst, begin, end } = this.createAlignedCopyForMapRead(\n      src,\n      expected[0].byteLength,\n      srcOffset\n    );\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const constructor = expected[0].constructor as TypedArrayBufferViewConstructor;\n      await dst.mapAsync(GPUMapMode.READ);\n      const actual = new constructor(dst.getMappedRange());\n\n      const bounds = [new constructor(expected[0].length), new constructor(expected[1].length)];\n      for (let i = 0, len = expected[0].length; i < len; i++) {\n        bounds[0][i] = Math.min(expected[0][i], expected[1][i]);\n        bounds[1][i] = Math.max(expected[0][i], expected[1][i]);\n      }\n\n      const check = this.checkBufferFn(\n        actual.subarray(begin, end),\n        (actual: TypedArrayBufferView) => {\n          if (actual.length !== expected[0].length) {\n            return false;\n          }\n          for (let i = 0, len = actual.length; i < len; i++) {\n            if (actual[i] < bounds[0][i] || actual[i] > bounds[1][i]) {\n              return false;\n            }\n          }\n          return true;\n        },\n        () => {\n          const lines: string[] = [];\n          const format = (x: number) => x.toString(16).padStart(2, '0');\n          const exp0Hex = Array.from(\n            new Uint8Array(\n              expected[0].buffer,\n              expected[0].byteOffset,\n              Math.min(expected[0].byteLength, 256)\n            ),\n            format\n          ).join('');\n          lines.push('EXPECT\\nbetween:\\t  ' + expected[0].join(' '));\n          lines.push('\\t0x' + exp0Hex);\n          if (expected[0].byteLength > 256) {\n            lines.push(' ...');\n          }\n          const exp1Hex = Array.from(\n            new Uint8Array(\n              expected[1].buffer,\n              expected[1].byteOffset,\n              Math.min(expected[1].byteLength, 256)\n            )\n          )\n            .map(format)\n            .join('');\n          lines.push('and:    \\t  ' + expected[1].join(' '));\n          lines.push('\\t0x' + exp1Hex);\n          if (expected[1].byteLength > 256) {\n            lines.push(' ...');\n          }\n          return lines.join('\\n');\n        }\n      );\n      if (check !== undefined) {\n        niceStack.message = check;\n        if (generateWarningOnly) {\n          this.rec.warn(niceStack);\n        } else {\n          this.rec.expectationFailed(niceStack);\n        }\n      }\n      dst.destroy();\n    });\n  }\n\n  // We can expand this function in order to support multiple valid values or two mixed vectors\n  // if needed. See the discussion at https://github.com/gpuweb/cts/pull/384#discussion_r533101429\n  expectContentsTwoValidValues(\n    src: GPUBuffer,\n    expected1: TypedArrayBufferView,\n    expected2: TypedArrayBufferView,\n    srcOffset: number = 0\n  ): void {\n    assert(expected1.byteLength === expected2.byteLength);\n    const { dst, begin, end } = this.createAlignedCopyForMapRead(\n      src,\n      expected1.byteLength,\n      srcOffset\n    );\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const constructor = expected1.constructor as TypedArrayBufferViewConstructor;\n      await dst.mapAsync(GPUMapMode.READ);\n      const actual = new constructor(dst.getMappedRange());\n      const check1 = this.checkBuffer(actual.subarray(begin, end), expected1);\n      const check2 = this.checkBuffer(actual.subarray(begin, end), expected2);\n      if (check1 !== undefined && check2 !== undefined) {\n        niceStack.message = `Expected one of the following two checks to succeed:\n  - ${check1}\n  - ${check2}`;\n        this.rec.expectationFailed(niceStack);\n      }\n      dst.destroy();\n    });\n  }\n\n  expectBuffer(actual: Uint8Array, exp: Uint8Array): void {\n    const check = this.checkBuffer(actual, exp);\n    if (check !== undefined) {\n      this.rec.expectationFailed(new Error(check));\n    }\n  }\n\n  checkBuffer(\n    actual: TypedArrayBufferView,\n    exp: TypedArrayBufferView,\n    tolerance: number | ((i: number) => number) = 0\n  ): string | undefined {\n    assert(actual.constructor === exp.constructor);\n\n    const size = exp.byteLength;\n    if (actual.byteLength !== size) {\n      return 'size mismatch';\n    }\n    const failedByteIndices: string[] = [];\n    const failedByteExpectedValues: string[] = [];\n    const failedByteActualValues: string[] = [];\n    for (let i = 0; i < size; ++i) {\n      const tol = typeof tolerance === 'function' ? tolerance(i) : tolerance;\n      if (Math.abs(actual[i] - exp[i]) > tol) {\n        if (failedByteIndices.length >= 4) {\n          failedByteIndices.push('...');\n          failedByteExpectedValues.push('...');\n          failedByteActualValues.push('...');\n          break;\n        }\n        failedByteIndices.push(i.toString());\n        failedByteExpectedValues.push(exp[i].toString());\n        failedByteActualValues.push(actual[i].toString());\n      }\n    }\n    const summary = `at [${failedByteIndices.join(', ')}], \\\nexpected [${failedByteExpectedValues.join(', ')}], \\\ngot [${failedByteActualValues.join(', ')}]`;\n    const lines = [summary];\n\n    // TODO: Could make a more convenient message, which could look like e.g.:\n    //\n    //   Starting at offset 48,\n    //              got 22222222 ABCDABCD 99999999\n    //     but expected 22222222 55555555 99999999\n    //\n    // or\n    //\n    //   Starting at offset 0,\n    //              got 00000000 00000000 00000000 00000000 (... more)\n    //     but expected 00FF00FF 00FF00FF 00FF00FF 00FF00FF (... more)\n    //\n    // Or, maybe these diffs aren't actually very useful (given we have the prints just above here),\n    // and we should remove them. More important will be logging of texture data in a visual format.\n\n    if (size <= 256 && failedByteIndices.length > 0) {\n      const expHex = Array.from(new Uint8Array(exp.buffer, exp.byteOffset, exp.byteLength))\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join('');\n      const actHex = Array.from(new Uint8Array(actual.buffer, actual.byteOffset, actual.byteLength))\n        .map(x => x.toString(16).padStart(2, '0'))\n        .join('');\n      lines.push('EXPECT:\\t  ' + exp.join(' '));\n      lines.push('\\t0x' + expHex);\n      lines.push('ACTUAL:\\t  ' + actual.join(' '));\n      lines.push('\\t0x' + actHex);\n    }\n    if (failedByteIndices.length) {\n      return lines.join('\\n');\n    }\n    return undefined;\n  }\n\n  checkBufferFn(\n    actual: TypedArrayBufferView,\n    checkFn: (actual: TypedArrayBufferView) => boolean,\n    errorMsgFn?: () => string\n  ): string | undefined {\n    const result = checkFn(actual);\n\n    if (result) {\n      return undefined;\n    }\n\n    const summary = 'CheckBuffer failed';\n    const lines = [summary];\n\n    const actHex = Array.from(\n      new Uint8Array(actual.buffer, actual.byteOffset, Math.min(actual.byteLength, 256))\n    )\n      .map(x => x.toString(16).padStart(2, '0'))\n      .join('');\n    lines.push('ACTUAL:\\t  ' + actual.join(' '));\n    lines.push('\\t0x' + actHex);\n\n    if (actual.byteLength > 256) {\n      lines.push(' ...');\n    }\n\n    if (errorMsgFn !== undefined) {\n      lines.push(errorMsgFn());\n    }\n\n    return lines.join('\\n');\n  }\n\n  expectSingleColor(\n    src: GPUTexture,\n    format: EncodableTextureFormat,\n    {\n      size,\n      exp,\n      dimension = '2d',\n      slice = 0,\n      layout,\n    }: {\n      size: [number, number, number];\n      exp: PerTexelComponent<number>;\n      dimension?: GPUTextureDimension;\n      slice?: number;\n      layout?: TextureLayoutOptions;\n    }\n  ): void {\n    const { byteLength, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n      format,\n      dimension,\n      size,\n      layout\n    );\n    const rep = kTexelRepresentationInfo[format];\n    const expectedTexelData = rep.pack(rep.encode(exp));\n\n    const buffer = this.device.createBuffer({\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyTextureToBuffer(\n      { texture: src, mipLevel: layout?.mipLevel, origin: { x: 0, y: 0, z: slice } },\n      { buffer, bytesPerRow, rowsPerImage },\n      mipSize\n    );\n    this.queue.submit([commandEncoder.finish()]);\n    const arrayBuffer = new ArrayBuffer(byteLength);\n    fillTextureDataWithTexelValue(expectedTexelData, format, dimension, arrayBuffer, size, layout);\n    this.expectContents(buffer, new Uint8Array(arrayBuffer));\n  }\n\n  // return a GPUBuffer that data are going to be written into\n  private readSinglePixelFrom2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    { slice = 0, layout }: { slice?: number; layout?: TextureLayoutOptions }\n  ): GPUBuffer {\n    const { byteLength, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n      format,\n      '2d',\n      [1, 1, 1],\n      layout\n    );\n    const buffer = this.device.createBuffer({\n      size: byteLength,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const commandEncoder = this.device.createCommandEncoder();\n    commandEncoder.copyTextureToBuffer(\n      { texture: src, mipLevel: layout?.mipLevel, origin: { x, y, z: slice } },\n      { buffer, bytesPerRow, rowsPerImage },\n      mipSize\n    );\n    this.queue.submit([commandEncoder.finish()]);\n\n    return buffer;\n  }\n\n  // TODO: Add check for values of depth/stencil, probably through sampling of shader\n  // TODO(natashalee): Can refactor this and expectSingleColor to use a similar base expect\n  expectSinglePixelIn2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    {\n      exp,\n      slice = 0,\n      layout,\n      generateWarningOnly = false,\n    }: {\n      exp: Uint8Array;\n      slice?: number;\n      layout?: TextureLayoutOptions;\n      generateWarningOnly?: boolean;\n    }\n  ): void {\n    const buffer = this.readSinglePixelFrom2DTexture(src, format, { x, y }, { slice, layout });\n    this.expectContents(buffer, exp, 0, { generateWarningOnly });\n  }\n\n  expectSinglePixelBetweenTwoValuesIn2DTexture(\n    src: GPUTexture,\n    format: SizedTextureFormat,\n    { x, y }: { x: number; y: number },\n    {\n      exp,\n      slice = 0,\n      layout,\n      generateWarningOnly = false,\n    }: {\n      exp: [TypedArrayBufferView, TypedArrayBufferView];\n      slice?: number;\n      layout?: TextureLayoutOptions;\n      generateWarningOnly?: boolean;\n    }\n  ): void {\n    const buffer = this.readSinglePixelFrom2DTexture(src, format, { x, y }, { slice, layout });\n    this.expectContentsBetweenTwoValues(buffer, exp, 0, { generateWarningOnly });\n  }\n\n  expectGPUError<R>(filter: GPUErrorFilter, fn: () => R, shouldError: boolean = true): R {\n    // If no error is expected, we let the scope surrounding the test catch it.\n    if (!shouldError) {\n      return fn();\n    }\n\n    this.device.pushErrorScope(filter);\n    const returnValue = fn();\n    const promise = this.device.popErrorScope();\n\n    this.eventualAsyncExpectation(async niceStack => {\n      const error = await promise;\n\n      let failed = false;\n      switch (filter) {\n        case 'out-of-memory':\n          failed = !(error instanceof GPUOutOfMemoryError);\n          break;\n        case 'validation':\n          failed = !(error instanceof GPUValidationError);\n          break;\n      }\n\n      if (failed) {\n        niceStack.message = `Expected ${filter} error`;\n        this.rec.expectationFailed(niceStack);\n      } else {\n        niceStack.message = `Captured ${filter} error`;\n        if (error instanceof GPUValidationError) {\n          niceStack.message += ` - ${error.message}`;\n        }\n        this.rec.debug(niceStack);\n      }\n    });\n\n    return returnValue;\n  }\n\n  makeBufferWithContents(dataArray: TypedArrayBufferView, usage: GPUBufferUsageFlags): GPUBuffer {\n    return makeBufferWithContents(this.device, dataArray, usage);\n  }\n\n  createTexture2DWithMipmaps(mipmapDataArray: TypedArrayBufferView[]): GPUTexture {\n    const format = 'rgba8unorm';\n    const mipLevelCount = mipmapDataArray.length;\n    const textureSizeMipmap0 = 1 << (mipLevelCount - 1);\n    const texture = this.device.createTexture({\n      mipLevelCount,\n      size: { width: textureSizeMipmap0, height: textureSizeMipmap0, depthOrArrayLayers: 1 },\n      format,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.SAMPLED,\n    });\n\n    const textureEncoder = this.device.createCommandEncoder();\n    for (let i = 0; i < mipLevelCount; i++) {\n      const { byteLength, bytesPerRow, rowsPerImage, mipSize } = getTextureCopyLayout(\n        format,\n        '2d',\n        [textureSizeMipmap0, textureSizeMipmap0, 1],\n        { mipLevel: i }\n      );\n\n      const data: Uint8Array = new Uint8Array(byteLength);\n      const mipLevelData = mipmapDataArray[i];\n      assert(rowsPerImage === mipSize[0]); // format is rgba8unorm and block size should be 1\n      for (let r = 0; r < rowsPerImage; r++) {\n        const o = r * bytesPerRow;\n        for (let c = o, end = o + mipSize[1] * 4; c < end; c += 4) {\n          data[c] = mipLevelData[0];\n          data[c + 1] = mipLevelData[1];\n          data[c + 2] = mipLevelData[2];\n          data[c + 3] = mipLevelData[3];\n        }\n      }\n      const buffer = this.makeBufferWithContents(\n        data,\n        GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n      );\n\n      textureEncoder.copyBufferToTexture(\n        { buffer, bytesPerRow, rowsPerImage },\n        { texture, mipLevel: i, origin: [0, 0, 0] },\n        mipSize\n      );\n    }\n    this.device.queue.submit([textureEncoder.finish()]);\n\n    return texture;\n  }\n}\n"],"file":"gpu_test.js"}