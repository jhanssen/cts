{"version":3,"sources":["../../../src/common/framework/test_group.ts"],"names":["SkipTestCase","extractPublicParams","mergeParams","kPathSeparator","stringifyPublicParams","stringifyPublicParamsUniquely","validQueryPart","assert","makeTestGroup","fixture","TestGroup","makeTestGroupForUnitTesting","seen","Set","tests","constructor","iterate","checkName","name","decodeURIComponent","has","add","test","testCreationStack","Error","parts","split","p","TestBuilder","push","validate","caseParams","undefined","subcaseParams","testPath","desc","description","trim","fn","testFn","unimplemented","testPathString","join","s","stack","testcase","testcaseString","testcaseStringUnique","params","casesIterable","cases","newSelf","Array","from","subcases","specs","RunCaseSpecific","subParamGen","id","runTest","rec","throwSkip","inst","init","finalize","ex","threw","run","start","totalCount","skipCount","subParams","info","message","skipped","finish"],"mappings":"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","sourcesContent":["import { Fixture, SkipTestCase } from './fixture.js';\nimport { TestCaseRecorder } from './logging/test_case_recorder.js';\nimport { CaseParams, extractPublicParams, Merged, mergeParams } from './params_utils.js';\nimport { kPathSeparator } from './query/separators.js';\nimport { stringifyPublicParams, stringifyPublicParamsUniquely } from './query/stringify_params.js';\nimport { validQueryPart } from './query/validQueryPart.js';\nimport { assert } from './util/util.js';\n\nexport type RunFn = (rec: TestCaseRecorder) => Promise<void>;\n\nexport interface TestCaseID {\n  readonly test: readonly string[];\n  readonly params: CaseParams;\n}\n\nexport interface RunCase {\n  readonly id: TestCaseID;\n  run: RunFn;\n}\n\n// Interface for defining tests\nexport interface TestGroupBuilder<F extends Fixture> {\n  test(name: string): TestBuilderWithName<F>;\n}\nexport function makeTestGroup<F extends Fixture>(fixture: FixtureClass<F>): TestGroupBuilder<F> {\n  return new TestGroup(fixture);\n}\n\n// Interfaces for running tests\nexport interface IterableTestGroup {\n  iterate(): Iterable<IterableTest>;\n  validate(): void;\n}\nexport interface IterableTest {\n  testPath: string[];\n  description: string | undefined;\n  readonly testCreationStack: Error;\n  iterate(): Iterable<RunCase>;\n}\n\nexport function makeTestGroupForUnitTesting<F extends Fixture>(\n  fixture: FixtureClass<F>\n): TestGroup<F> {\n  return new TestGroup(fixture);\n}\n\ntype FixtureClass<F extends Fixture> = new <P extends {}>(log: TestCaseRecorder, params: P) => F;\ntype TestFn<F extends Fixture, P extends {}, SubP extends {}> = (\n  t: F & { params: Merged<P, SubP> }\n) => Promise<void> | void;\n\nclass TestGroup<F extends Fixture> implements TestGroupBuilder<F> {\n  private fixture: FixtureClass<F>;\n  private seen: Set<string> = new Set();\n  private tests: Array<TestBuilder<F, {}, {}>> = [];\n\n  constructor(fixture: FixtureClass<F>) {\n    this.fixture = fixture;\n  }\n\n  iterate(): Iterable<IterableTest> {\n    return this.tests;\n  }\n\n  private checkName(name: string): void {\n    assert(\n      // Shouldn't happen due to the rule above. Just makes sure that treated\n      // unencoded strings as encoded strings is OK.\n      name === decodeURIComponent(name),\n      `Not decodeURIComponent-idempotent: ${name} !== ${decodeURIComponent(name)}`\n    );\n    assert(!this.seen.has(name), `Duplicate test name: ${name}`);\n\n    this.seen.add(name);\n  }\n\n  // TODO: This could take a fixture, too, to override the one for the group.\n  test(name: string): TestBuilderWithName<F> {\n    const testCreationStack = new Error(`Test created: ${name}`);\n\n    this.checkName(name);\n\n    const parts = name.split(kPathSeparator);\n    for (const p of parts) {\n      assert(validQueryPart.test(p), `Invalid test name part ${p}; must match ${validQueryPart}`);\n    }\n\n    const test = new TestBuilder<F, {}, {}>(parts, this.fixture, testCreationStack);\n    this.tests.push(test);\n    return test;\n  }\n\n  validate(): void {\n    for (const test of this.tests) {\n      test.validate();\n    }\n  }\n}\n\ninterface TestBuilderWithName<F extends Fixture> extends TestBuilderWithParams<F, {}> {\n  desc(description: string): this;\n  /** @deprecated use cases() and/or subcases() instead */\n  params<NewP extends {}>(specs: Iterable<NewP>): TestBuilderWithParams<F, NewP>;\n  cases<NewP extends {}>(specs: Iterable<NewP>): TestBuilderWithParams<F, NewP>;\n}\n\ninterface TestBuilderWithParams<F extends Fixture, P extends {}>\n  extends TestBuilderWithSubParams<F, P, {}> {\n  subcases<NewSubP extends {}>(\n    specs: (_: P) => Iterable<NewSubP>\n  ): TestBuilderWithSubParams<F, P, NewSubP>;\n}\n\ninterface TestBuilderWithSubParams<F extends Fixture, P extends {}, SubP extends {}> {\n  fn(fn: TestFn<F, P, SubP>): void;\n  unimplemented(): void;\n}\n\nclass TestBuilder<F extends Fixture, P extends {}, SubP extends {}> {\n  readonly testPath: string[];\n  description: string | undefined;\n  readonly testCreationStack: Error;\n\n  private readonly fixture: FixtureClass<F>;\n  private testFn: TestFn<F, P, SubP> | undefined;\n  private caseParams?: Iterable<P> = undefined;\n  private subcaseParams?: (_: P) => Iterable<SubP> = undefined;\n\n  constructor(testPath: string[], fixture: FixtureClass<F>, testCreationStack: Error) {\n    this.testPath = testPath;\n    this.fixture = fixture;\n    this.testCreationStack = testCreationStack;\n  }\n\n  desc(description: string): this {\n    this.description = description.trim();\n    return this;\n  }\n\n  fn(fn: TestFn<F, P, SubP>): void {\n    // TODO: add TODO if there's no description? (and make sure it only ends up on actual tests,\n    // not on test parents in the tree, which is what happens if you do it here, not sure why)\n    assert(this.testFn === undefined);\n    this.testFn = fn;\n  }\n\n  unimplemented(): void {\n    assert(this.testFn === undefined);\n\n    this.description =\n      (this.description ? this.description + '\\n\\n' : '') + 'TODO: .unimplemented()';\n\n    this.testFn = () => {\n      throw new SkipTestCase('test unimplemented');\n    };\n  }\n\n  validate(): void {\n    const testPathString = this.testPath.join(kPathSeparator);\n    assert(this.testFn !== undefined, () => {\n      let s = `Test is missing .fn(): ${testPathString}`;\n      if (this.testCreationStack.stack) {\n        s += `\\n-> test created at:\\n${this.testCreationStack.stack}`;\n      }\n      return s;\n    });\n\n    if (this.caseParams === undefined) {\n      return;\n    }\n\n    const seen = new Set<string>();\n    for (const testcase of this.caseParams) {\n      // stringifyPublicParams also checks for invalid params values\n      const testcaseString = stringifyPublicParams(testcase);\n\n      // A (hopefully) unique representation of a params value.\n      const testcaseStringUnique = stringifyPublicParamsUniquely(testcase);\n      assert(\n        !seen.has(testcaseStringUnique),\n        `Duplicate public test case params for test ${testPathString}: ${testcaseString}`\n      );\n      seen.add(testcaseStringUnique);\n    }\n  }\n\n  params<NewP extends {}>(casesIterable: Iterable<NewP>): TestBuilder<F, NewP, SubP> {\n    return this.cases(casesIterable);\n  }\n\n  cases<NewP extends {}>(casesIterable: Iterable<NewP>): TestBuilder<F, NewP, SubP> {\n    assert(this.caseParams === undefined, 'test case is already parameterized');\n    const newSelf = (this as unknown) as TestBuilder<F, NewP, SubP>;\n    newSelf.caseParams = Array.from(casesIterable);\n\n    return newSelf;\n  }\n\n  subcases<NewSubP extends {}>(specs: (_: P) => Iterable<NewSubP>): TestBuilder<F, P, NewSubP> {\n    assert(this.subcaseParams === undefined, 'test subcases are already parameterized');\n    const newSelf = (this as unknown) as TestBuilder<F, P, NewSubP>;\n    newSelf.subcaseParams = specs;\n\n    return newSelf;\n  }\n\n  *iterate(): IterableIterator<RunCase> {\n    assert(this.testFn !== undefined, 'No test function (.fn()) for test');\n    for (const params of this.caseParams || [<P>{}]) {\n      yield new RunCaseSpecific(\n        this.testPath,\n        params,\n        this.subcaseParams,\n        this.fixture,\n        this.testFn\n      );\n    }\n  }\n}\n\nclass RunCaseSpecific<\n  F extends Fixture,\n  P extends CaseParams,\n  SubP extends CaseParams,\n  FN extends TestFn<F, P, SubP>\n> implements RunCase {\n  readonly id: TestCaseID;\n\n  private readonly params: P;\n  private readonly subParamGen?: (_: P) => Iterable<SubP>;\n  private readonly fixture: FixtureClass<F>;\n  private readonly fn: FN;\n\n  constructor(\n    testPath: string[],\n    params: P,\n    subParamGen: ((_: P) => Iterable<SubP>) | undefined,\n    fixture: FixtureClass<F>,\n    fn: FN\n  ) {\n    this.id = { test: testPath, params: extractPublicParams(params) };\n    this.params = params;\n    this.subParamGen = subParamGen;\n    this.fixture = fixture;\n    this.fn = fn;\n  }\n\n  async runTest(\n    rec: TestCaseRecorder,\n    params: P | Merged<P, SubP>,\n    throwSkip: boolean\n  ): Promise<void> {\n    try {\n      const inst = new this.fixture(rec, params);\n\n      try {\n        await inst.init();\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        await this.fn(inst as any);\n      } finally {\n        // Runs as long as constructor succeeded, even if initialization or the test failed.\n        await inst.finalize();\n      }\n    } catch (ex) {\n      // There was an exception from constructor, init, test, or finalize.\n      // An error from init or test may have been a SkipTestCase.\n      // An error from finalize may have been an eventualAsyncExpectation failure\n      // or unexpected validation/OOM error from the GPUDevice.\n      if (throwSkip && ex instanceof SkipTestCase) {\n        throw ex;\n      }\n      rec.threw(ex);\n    }\n  }\n\n  async run(rec: TestCaseRecorder): Promise<void> {\n    rec.start();\n    if (this.subParamGen) {\n      let totalCount = 0;\n      let skipCount = 0;\n      for (const subParams of this.subParamGen(this.params)) {\n        rec.info(new Error('subcase: ' + stringifyPublicParams(subParams)));\n        try {\n          await this.runTest(rec, mergeParams(this.params, subParams), true);\n        } catch (ex) {\n          if (ex instanceof SkipTestCase) {\n            // Convert SkipTestCase to info messages\n            ex.message = 'subcase skipped: ' + ex.message;\n            rec.info(ex);\n            ++skipCount;\n          } else {\n            // Since we are catching all error inside runTest(), this should never happen\n            rec.threw(ex);\n          }\n        }\n        ++totalCount;\n      }\n      if (skipCount === totalCount) {\n        rec.skipped(new SkipTestCase('all subcases were skipped'));\n      }\n    } else {\n      await this.runTest(rec, this.params, false);\n    }\n    rec.finish();\n  }\n}\n"],"file":"test_group.js"}