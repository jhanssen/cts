{"version":3,"sources":["../../../src/common/framework/params_utils.ts"],"names":["comparePublicParamsPaths","Ordering","kWildcard","kParamSeparator","kParamKVSeparator","assert","paramKeyIsPublic","key","startsWith","extractPublicParams","params","publicParams","k","Object","keys","badParamValueChars","RegExp","publicParamsEquals","x","y","Equal","mergeParams","a","b"],"mappings":";AAAA;AACA,GADA,SAASA,wBAAT,EAAmCC,QAAnC,QAAmD,oBAAnD,CACA,SAASC,SAAT,EAAoBC,eAApB,EAAqCC,iBAArC,QAA8D,uBAA9D;AAEA,SAASC,MAAT,QAAuB,gBAAvB;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAiBA,OAAO,SAASC,gBAAT,CAA0BC,GAA1B,EAAgD;AACrD,SAAO,CAACA,GAAG,CAACC,UAAJ,CAAe,GAAf,CAAR;AACD;;AAED,OAAO,SAASC,mBAAT,CAA6BC,MAA7B,EAA6D;AAClE,QAAMC,YAA0B,GAAG,EAAnC;AACA,OAAK,MAAMC,CAAX,IAAgBC,MAAM,CAACC,IAAP,CAAYJ,MAAZ,CAAhB,EAAqC;AACnC,QAAIJ,gBAAgB,CAACM,CAAD,CAApB,EAAyB;AACvBD,MAAAA,YAAY,CAACC,CAAD,CAAZ,GAAkBF,MAAM,CAACE,CAAD,CAAxB;AACD;AACF;AACD,SAAOD,YAAP;AACD;;AAED,OAAO,MAAMI,kBAAkB,GAAG,IAAIC,MAAJ;AAChC,MAAMZ,iBAAN,GAA0BD,eAA1B,GAA4CD,SAA5C,GAAwD,GADxB,CAA3B;;;AAIP,OAAO,SAASe,kBAAT,CAA4BC,CAA5B,EAA2CC,CAA3C,EAAmE;AACxE,SAAOnB,wBAAwB,CAACkB,CAAD,EAAIC,CAAJ,CAAxB,KAAmClB,QAAQ,CAACmB,KAAnD;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCU;;AAEX,OAAO,SAASC,WAAT,CAAiDC,CAAjD,EAAuDC,CAAvD,EAA2E;AAChF,OAAK,MAAMhB,GAAX,IAAkBM,MAAM,CAACC,IAAP,CAAYQ,CAAZ,CAAlB,EAAkC;AAChCjB,IAAAA,MAAM,CAAC,EAAEE,GAAG,IAAIgB,CAAT,CAAD,EAAc,oBAAoBhB,GAAlC,CAAN;AACD;AACD,SAAO,EAAE,GAAGe,CAAL,EAAQ,GAAGC,CAAX,EAAP;AACD","sourcesContent":["import { comparePublicParamsPaths, Ordering } from './query/compare.js';\nimport { kWildcard, kParamSeparator, kParamKVSeparator } from './query/separators.js';\nimport { UnionToIntersection } from './util/types.js';\nimport { assert } from './util/util.js';\n\n// Consider adding more types here if needed\n//\n// TODO: This type isn't actually used to constrain what you're allowed to do in `.params()`, so\n// it's not really serving its purpose. Figure out how to fix that?\nexport type ParamArgument =\n  | undefined\n  | null\n  | number\n  | string\n  | boolean\n  | number[]\n  | { readonly [k: string]: undefined | null | number | string | boolean };\nexport type CaseParams = {\n  readonly [k: string]: ParamArgument;\n};\nexport interface CaseParamsRW {\n  [k: string]: ParamArgument;\n}\nexport type CaseParamsIterable = Iterable<CaseParams>;\n\nexport function paramKeyIsPublic(key: string): boolean {\n  return !key.startsWith('_');\n}\n\nexport function extractPublicParams(params: CaseParams): CaseParams {\n  const publicParams: CaseParamsRW = {};\n  for (const k of Object.keys(params)) {\n    if (paramKeyIsPublic(k)) {\n      publicParams[k] = params[k];\n    }\n  }\n  return publicParams;\n}\n\nexport const badParamValueChars = new RegExp(\n  '[' + kParamKVSeparator + kParamSeparator + kWildcard + ']'\n);\n\nexport function publicParamsEquals(x: CaseParams, y: CaseParams): boolean {\n  return comparePublicParamsPaths(x, y) === Ordering.Equal;\n}\n\nexport type KeyOfNeverable<T> = T extends never ? never : keyof T;\nexport type AllKeysFromUnion<T> = keyof T | KeyOfNeverable<UnionToIntersection<T>>;\nexport type KeyOfOr<T, K, Default> = K extends keyof T ? T[K] : Default;\n\n/**\n * Flatten a union of interfaces into a single interface encoding the same type.\n *\n * Flattens a union in such a way that:\n * `{ a: number, b?: undefined } | { b: string, a?: undefined }`\n * (which is the value type of `[{ a: 1 }, { b: 1 }]`)\n * becomes `{ a: number | undefined, b: string | undefined }`.\n *\n * And also works for `{ a: number } | { b: string }` which maps to the same.\n */\nexport type FlattenUnionOfInterfaces<T> = {\n  [K in AllKeysFromUnion<T>]: KeyOfOr<\n    T,\n    // If T always has K, just take T[K] (union of C[K] for each component C of T):\n    K,\n    // Otherwise, take the union of C[K] for each component C of T, PLUS undefined:\n    undefined | KeyOfOr<UnionToIntersection<T>, K, void>\n  >;\n};\n\nexport type ValueTypeForKeyOfMergedType<A, B, Key extends keyof A | keyof B> = Key extends keyof A\n  ? Key extends keyof B\n    ? void // Key is in both types\n    : A[Key] // Key is only in A\n  : Key extends keyof B\n  ? B[Key] // Key is only in B\n  : void; // Key is in neither type (not possible)\n\nexport type Merged<A, B> = MergedFromFlat<A, FlattenUnionOfInterfaces<B>>;\nexport type MergedFromFlat<A, B> = keyof A & keyof B extends never\n  ? string extends keyof A | keyof B\n    ? never // (keyof A | keyof B) == string, which is too broad\n    : {\n        [Key in keyof A | keyof B]: ValueTypeForKeyOfMergedType<A, B, Key>;\n      }\n  : never; // (keyof A & keyof B) is not empty, so they overlapped\n\nexport function mergeParams<A extends {}, B extends {}>(a: A, b: B): Merged<A, B> {\n  for (const key of Object.keys(a)) {\n    assert(!(key in b), 'Duplicate key: ' + key);\n  }\n  return { ...a, ...b } as Merged<A, B>;\n}\n"],"file":"params_utils.js"}