{"version":3,"sources":["../../../src/common/framework/params_builder.ts"],"names":["mergeParams","publicParamsEquals","typeAssert","poptions","name","values","iter","makeReusableIterable","value","pbool","params","ParamsBuilder","paramSpecs","Symbol","iterator","combine","newParams","a","b","expand","expander","filter","pred","p","unless","x","exclude","excludeArray","Array","from","every","e","generatorFn"],"mappings":"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","sourcesContent":["import {\n  CaseParams,\n  CaseParamsIterable,\n  FlattenUnionOfInterfaces,\n  Merged,\n  mergeParams,\n  publicParamsEquals,\n} from './params_utils.js';\nimport { ResolveType, UnionToIntersection } from './util/types.js';\n\n/** Conditionally chooses between two types depending on whether T is a union. */\ntype CheckForUnion<T, TErr, TOk> = [T] extends [UnionToIntersection<T>] ? TOk : TErr;\n\n/** Conditionally chooses a type (or void) depending on whether T is a string. */\ntype CheckForStringLiteralType<T, TOk> = string extends T ? void : CheckForUnion<T, void, TOk>;\n\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\nfunction typeAssert<T extends 'pass'>() {}\n{\n  type Test<T, U> = [T] extends [U]\n    ? [U] extends [T]\n      ? 'pass'\n      : { actual: ResolveType<T>; expected: U }\n    : { actual: ResolveType<T>; expected: U };\n\n  type T01 = { a: number } | { b: string };\n  type T02 = { a: number } | { b?: string };\n  type T03 = { a: number } | { a?: number };\n  type T04 = { a: number } | { a: string };\n  type T05 = { a: number } | { a?: string };\n\n  type T11 = { a: number; b?: undefined } | { a?: undefined; b: string };\n\n  type T21 = { a: number; b?: undefined } | { b: string };\n  type T22 = { a: number; b?: undefined } | { b?: string };\n  type T23 = { a: number; b?: undefined } | { a?: number };\n  type T24 = { a: number; b?: undefined } | { a: string };\n  type T25 = { a: number; b?: undefined } | { a?: string };\n  type T26 = { a: number; b?: undefined } | { a: undefined };\n  type T27 = { a: number; b?: undefined } | { a: undefined; b: undefined };\n\n  /* prettier-ignore */ {\n    typeAssert<Test<FlattenUnionOfInterfaces<T01>, { a: number | undefined; b: string | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T02>, { a: number | undefined; b: string | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T03>, { a: number | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T04>, { a: number | string }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T05>, { a: number | string | undefined }>>();\n\n    typeAssert<Test<FlattenUnionOfInterfaces<T11>, { a: number | undefined; b: string | undefined }>>();\n\n    typeAssert<Test<FlattenUnionOfInterfaces<T22>, { a: number | undefined; b: string | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T23>, { a: number | undefined; b: undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T24>, { a: number | string; b: undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T25>, { a: number | string | undefined; b: undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T27>, { a: number | undefined; b: undefined }>>();\n\n    // Unexpected test results - hopefully okay to ignore these\n    typeAssert<Test<FlattenUnionOfInterfaces<T21>, { b: string | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T26>, { a: number | undefined }>>();\n  }\n}\n\nexport function poptions<Name extends string, V>(\n  name: Name,\n  values: Iterable<V>\n): CheckForStringLiteralType<Name, Iterable<{ [name in Name]: V }>> {\n  const iter = makeReusableIterable(function* () {\n    for (const value of values) {\n      yield { [name]: value };\n    }\n  });\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  return iter as any;\n}\n\nexport function pbool<Name extends string>(\n  name: Name\n): CheckForStringLiteralType<Name, Iterable<{ [name in Name]: boolean }>> {\n  return poptions(name, [false, true]);\n}\n\nexport function params(): ParamsBuilder<{}> {\n  return new ParamsBuilder();\n}\n\nexport class ParamsBuilder<A extends {}> implements CaseParamsIterable {\n  private paramSpecs: CaseParamsIterable = [{}];\n\n  [Symbol.iterator](): Iterator<A> {\n    const iter: Iterator<CaseParams> = this.paramSpecs[Symbol.iterator]();\n    return iter as Iterator<A>;\n  }\n\n  combine<B extends {}>(newParams: Iterable<B>): ParamsBuilder<Merged<A, B>> {\n    const paramSpecs = this.paramSpecs as Iterable<A>;\n    this.paramSpecs = makeReusableIterable(function* () {\n      for (const a of paramSpecs) {\n        for (const b of newParams) {\n          yield mergeParams(a, b);\n        }\n      }\n    }) as CaseParamsIterable;\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    return this as any;\n  }\n\n  expand<B extends {}>(expander: (_: A) => Iterable<B>): ParamsBuilder<Merged<A, B>> {\n    const paramSpecs = this.paramSpecs as Iterable<A>;\n    this.paramSpecs = makeReusableIterable(function* () {\n      for (const a of paramSpecs) {\n        for (const b of expander(a)) {\n          yield mergeParams(a, b);\n        }\n      }\n    }) as CaseParamsIterable;\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    return this as any;\n  }\n\n  filter(pred: (_: A) => boolean): ParamsBuilder<A> {\n    const paramSpecs = this.paramSpecs as Iterable<A>;\n    this.paramSpecs = makeReusableIterable(function* () {\n      for (const p of paramSpecs) {\n        if (pred(p)) {\n          yield p;\n        }\n      }\n    });\n    return this;\n  }\n\n  unless(pred: (_: A) => boolean): ParamsBuilder<A> {\n    return this.filter(x => !pred(x));\n  }\n\n  exclude(exclude: CaseParamsIterable): ParamsBuilder<A> {\n    const excludeArray = Array.from(exclude);\n    const paramSpecs = this.paramSpecs;\n    this.paramSpecs = makeReusableIterable(function* () {\n      for (const p of paramSpecs) {\n        if (excludeArray.every(e => !publicParamsEquals(p, e))) {\n          yield p;\n        }\n      }\n    });\n    return this;\n  }\n}\n\n// If you create an Iterable by calling a generator function (e.g. in IIFE), it is exhausted after\n// one use. This just wraps a generator function in an object so it be iterated multiple times.\nfunction makeReusableIterable<P>(generatorFn: () => Generator<P>): Iterable<P> {\n  return { [Symbol.iterator]: generatorFn };\n}\n"],"file":"params_builder.js"}